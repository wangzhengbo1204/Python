#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Nov 09 11:51:55 2011 by generateDS.py version 2.7a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class DownloadingConfig(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self, StartTime=None, EndTime=None, Frequency=None, WebSetting=None, DatabaseSetting=None, LocalSetting=None, DocCategory=None):
        self.StartTime = StartTime
        self.EndTime = EndTime
        self.Frequency = Frequency
        self.WebSetting = WebSetting
        self.DatabaseSetting = DatabaseSetting
        self.LocalSetting = LocalSetting
        self.DocCategory = DocCategory
    def factory(*args_, **kwargs_):
        if DownloadingConfig.subclass:
            return DownloadingConfig.subclass(*args_, **kwargs_)
        else:
            return DownloadingConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def get_WebSetting(self): return self.WebSetting
    def set_WebSetting(self, WebSetting): self.WebSetting = WebSetting
    def get_DatabaseSetting(self): return self.DatabaseSetting
    def set_DatabaseSetting(self, DatabaseSetting): self.DatabaseSetting = DatabaseSetting
    def get_LocalSetting(self): return self.LocalSetting
    def set_LocalSetting(self, LocalSetting): self.LocalSetting = LocalSetting
    def get_DocCategory(self): return self.DocCategory
    def set_DocCategory(self, DocCategory): self.DocCategory = DocCategory
    def export(self, outfile, level, namespace_='', name_='DownloadingConfig', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DownloadingConfig')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DownloadingConfig'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DownloadingConfig', fromsubclass_=False):
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sStartTime>%s</%sStartTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), namespace_))
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sEndTime>%s</%sEndTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.EndTime).encode(ExternalEncoding), input_name='EndTime'), namespace_))
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('<%sFrequency>%s</%sFrequency>\n' % (namespace_, self.gds_format_string(quote_xml(self.Frequency).encode(ExternalEncoding), input_name='Frequency'), namespace_))
        if self.WebSetting is not None:
            self.WebSetting.export(outfile, level, namespace_, name_='WebSetting')
        if self.DatabaseSetting is not None:
            self.DatabaseSetting.export(outfile, level, namespace_, name_='DatabaseSetting')
        if self.LocalSetting is not None:
            self.LocalSetting.export(outfile, level, namespace_, name_='LocalSetting')
        if self.DocCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sDocCategory>%s</%sDocCategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.DocCategory).encode(ExternalEncoding), input_name='DocCategory'), namespace_))
    def hasContent_(self):
        if (
            self.StartTime is not None or
            self.EndTime is not None or
            self.Frequency is not None or
            self.WebSetting is not None or
            self.DatabaseSetting is not None or
            self.LocalSetting is not None or
            self.DocCategory is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DownloadingConfig'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=%s,\n' % quote_python(self.StartTime).encode(ExternalEncoding))
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=%s,\n' % quote_python(self.EndTime).encode(ExternalEncoding))
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=%s,\n' % quote_python(self.Frequency).encode(ExternalEncoding))
        if self.WebSetting is not None:
            showIndent(outfile, level)
            outfile.write('WebSetting=model_.WebSettingType(\n')
            self.WebSetting.exportLiteral(outfile, level, name_='WebSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DatabaseSetting is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseSetting=model_.DatabaseSettingType(\n')
            self.DatabaseSetting.exportLiteral(outfile, level, name_='DatabaseSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalSetting is not None:
            showIndent(outfile, level)
            outfile.write('LocalSetting=model_.LocalSettingType(\n')
            self.LocalSetting.exportLiteral(outfile, level, name_='LocalSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocCategory is not None:
            showIndent(outfile, level)
            outfile.write('DocCategory=%s,\n' % quote_python(self.DocCategory).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
        elif nodeName_ == 'Frequency':
            Frequency_ = child_.text
            Frequency_ = self.gds_validate_string(Frequency_, node, 'Frequency')
            self.Frequency = Frequency_
        elif nodeName_ == 'WebSetting':
            obj_ = WebSettingType.factory()
            obj_.build(child_)
            self.set_WebSetting(obj_)
        elif nodeName_ == 'DatabaseSetting':
            obj_ = DatabaseSettingType.factory()
            obj_.build(child_)
            self.set_DatabaseSetting(obj_)
        elif nodeName_ == 'LocalSetting':
            obj_ = LocalSettingType.factory()
            obj_.build(child_)
            self.set_LocalSetting(obj_)
        elif nodeName_ == 'DocCategory':
            DocCategory_ = child_.text
            DocCategory_ = self.gds_validate_string(DocCategory_, node, 'DocCategory')
            self.DocCategory = DocCategory_
# end class DownloadingConfig


class StartTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if StartTime.subclass:
            return StartTime.subclass(*args_, **kwargs_)
        else:
            return StartTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='StartTime', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartTime')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StartTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StartTime', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StartTime'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StartTime


class EndTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if EndTime.subclass:
            return EndTime.subclass(*args_, **kwargs_)
        else:
            return EndTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='EndTime', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndTime')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndTime'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndTime', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndTime'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EndTime


class Frequency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Frequency.subclass:
            return Frequency.subclass(*args_, **kwargs_)
        else:
            return Frequency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Frequency', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Frequency')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Frequency'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Frequency', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Frequency'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Frequency


class DocCategory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DocCategory.subclass:
            return DocCategory.subclass(*args_, **kwargs_)
        else:
            return DocCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DocCategory', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocCategory')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocCategory'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocCategory', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocCategory'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocCategory


class WebSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, URL=None, Encoding=None, ParseSolution=None, Structe=None, Delimiter=None, Period=None, SearchByDateType=None, Step=None):
        self.URL = URL
        self.Encoding = Encoding
        self.ParseSolution = ParseSolution
        self.Structe = Structe
        self.Delimiter = Delimiter
        self.Period = Period
        self.SearchByDateType = SearchByDateType
        self.Step = Step
    def factory(*args_, **kwargs_):
        if WebSettingType.subclass:
            return WebSettingType.subclass(*args_, **kwargs_)
        else:
            return WebSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def get_ParseSolution(self): return self.ParseSolution
    def set_ParseSolution(self, ParseSolution): self.ParseSolution = ParseSolution
    def get_Structe(self): return self.Structe
    def set_Structe(self, Structe): self.Structe = Structe
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_Period(self): return self.Period
    def set_Period(self, Period): self.Period = Period
    def get_SearchByDateType(self): return self.SearchByDateType
    def set_SearchByDateType(self, SearchByDateType): self.SearchByDateType = SearchByDateType
    def get_Step(self): return self.Step
    def set_Step(self, Step): self.Step = Step
    def export(self, outfile, level, namespace_='', name_='WebSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WebSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WebSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WebSettingType', fromsubclass_=False):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('<%sURL>%s</%sURL>\n' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_))
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('<%sEncoding>%s</%sEncoding>\n' % (namespace_, self.gds_format_string(quote_xml(self.Encoding).encode(ExternalEncoding), input_name='Encoding'), namespace_))
        if self.ParseSolution is not None:
            showIndent(outfile, level)
            outfile.write('<%sParseSolution>%s</%sParseSolution>\n' % (namespace_, self.gds_format_string(quote_xml(self.ParseSolution).encode(ExternalEncoding), input_name='ParseSolution'), namespace_))
        if self.Structe is not None:
            showIndent(outfile, level)
            outfile.write('<%sStructe>%s</%sStructe>\n' % (namespace_, self.gds_format_string(quote_xml(self.Structe).encode(ExternalEncoding), input_name='Structe'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
        if self.Period is not None:
            self.Period.export(outfile, level, namespace_, name_='Period', )
        if self.SearchByDateType is not None:
            self.SearchByDateType.export(outfile, level, namespace_, name_='SearchByDateType', )
        if self.Step is not None:
            self.Step.export(outfile, level, namespace_, name_='Step', )
    def hasContent_(self):
        if (
            self.URL is not None or
            self.Encoding is not None or
            self.ParseSolution is not None or
            self.Structe is not None or
            self.Delimiter is not None or
            self.Period is not None or
            self.SearchByDateType is not None or
            self.Step is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WebSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Encoding=%s,\n' % quote_python(self.Encoding).encode(ExternalEncoding))
        if self.ParseSolution is not None:
            showIndent(outfile, level)
            outfile.write('ParseSolution=%s,\n' % quote_python(self.ParseSolution).encode(ExternalEncoding))
        if self.Structe is not None:
            showIndent(outfile, level)
            outfile.write('Structe=%s,\n' % quote_python(self.Structe).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
        if self.Period is not None:
            showIndent(outfile, level)
            outfile.write('Period=model_.PeriodType(\n')
            self.Period.exportLiteral(outfile, level, name_='Period')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SearchByDateType is not None:
            showIndent(outfile, level)
            outfile.write('SearchByDateType=model_.SearchByDateTypeType(\n')
            self.SearchByDateType.exportLiteral(outfile, level, name_='SearchByDateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Step is not None:
            showIndent(outfile, level)
            outfile.write('Step=model_.StepType(\n')
            self.Step.exportLiteral(outfile, level, name_='Step')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'Encoding':
            Encoding_ = child_.text
            Encoding_ = self.gds_validate_string(Encoding_, node, 'Encoding')
            self.Encoding = Encoding_
        elif nodeName_ == 'ParseSolution':
            ParseSolution_ = child_.text
            ParseSolution_ = self.gds_validate_string(ParseSolution_, node, 'ParseSolution')
            self.ParseSolution = ParseSolution_
        elif nodeName_ == 'Structe':
            Structe_ = child_.text
            Structe_ = self.gds_validate_string(Structe_, node, 'Structe')
            self.Structe = Structe_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
        elif nodeName_ == 'Period':
            obj_ = PeriodType.factory()
            obj_.build(child_)
            self.set_Period(obj_)
        elif nodeName_ == 'SearchByDateType':
            obj_ = SearchByDateTypeType.factory()
            obj_.build(child_)
            self.set_SearchByDateType(obj_)
        elif nodeName_ == 'Step':
            obj_ = StepType.factory()
            obj_.build(child_)
            self.set_Step(obj_)
# end class WebSettingType


class URL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if URL.subclass:
            return URL.subclass(*args_, **kwargs_)
        else:
            return URL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='URL', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='URL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class URL


class Encoding(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Encoding.subclass:
            return Encoding.subclass(*args_, **kwargs_)
        else:
            return Encoding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Encoding', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Encoding')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Encoding'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Encoding', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Encoding'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Encoding


class ParseSolution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ParseSolution.subclass:
            return ParseSolution.subclass(*args_, **kwargs_)
        else:
            return ParseSolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ParseSolution', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParseSolution')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParseSolution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParseSolution', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParseSolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParseSolution


class Structe(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Structe.subclass:
            return Structe.subclass(*args_, **kwargs_)
        else:
            return Structe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Structe', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Structe')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Structe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Structe', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Structe'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Structe


class Delimiter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Delimiter.subclass:
            return Delimiter.subclass(*args_, **kwargs_)
        else:
            return Delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Delimiter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Delimiter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Delimiter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Delimiter', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Delimiter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Delimiter


class PeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartDate=None, EndDate=None):
        self.StartDate = StartDate
        self.EndDate = EndDate
    def factory(*args_, **kwargs_):
        if PeriodType.subclass:
            return PeriodType.subclass(*args_, **kwargs_)
        else:
            return PeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def export(self, outfile, level, namespace_='', name_='PeriodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeriodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PeriodType', fromsubclass_=False):
        if self.StartDate is not None:
            self.StartDate.export(outfile, level, namespace_, name_='StartDate', )
        if self.EndDate is not None:
            self.EndDate.export(outfile, level, namespace_, name_='EndDate', )
    def hasContent_(self):
        if (
            self.StartDate is not None or
            self.EndDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PeriodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartDate is not None:
            showIndent(outfile, level)
            outfile.write('StartDate=model_.StartDateType(\n')
            self.StartDate.exportLiteral(outfile, level, name_='StartDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=model_.EndDateType(\n')
            self.EndDate.exportLiteral(outfile, level, name_='EndDate')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartDate':
            obj_ = StartDateType.factory()
            obj_.build(child_)
            self.set_StartDate(obj_)
        elif nodeName_ == 'EndDate':
            obj_ = EndDateType.factory()
            obj_.build(child_)
            self.set_EndDate(obj_)
# end class PeriodType


class StartDateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.Type = Type
        self.Value = Value
    def factory(*args_, **kwargs_):
        if StartDateType.subclass:
            return StartDateType.subclass(*args_, **kwargs_)
        else:
            return StartDateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='', name_='StartDateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartDateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StartDateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StartDateType', fromsubclass_=False):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StartDateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class StartDateType


class Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Type.subclass:
            return Type.subclass(*args_, **kwargs_)
        else:
            return Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Type


class Value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Value', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Value')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Value'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Value', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Value'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Value


class EndDateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Value=None):
        self.Type = Type
        self.Value = Value
    def factory(*args_, **kwargs_):
        if EndDateType.subclass:
            return EndDateType.subclass(*args_, **kwargs_)
        else:
            return EndDateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='', name_='EndDateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndDateType', fromsubclass_=False):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('<%sType>%s</%sType>\n' % (namespace_, self.gds_format_string(quote_xml(self.Type).encode(ExternalEncoding), input_name='Type'), namespace_))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.Type is not None or
            self.Value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndDateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type=%s,\n' % quote_python(self.Type).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Type':
            Type_ = child_.text
            Type_ = self.gds_validate_string(Type_, node, 'Type')
            self.Type = Type_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class EndDateType


class SearchByDateTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if SearchByDateTypeType.subclass:
            return SearchByDateTypeType.subclass(*args_, **kwargs_)
        else:
            return SearchByDateTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SearchByDateTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SearchByDateTypeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SearchByDateTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SearchByDateTypeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SearchByDateTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SearchByDateTypeType


class StepType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Filter=None, MappingID=None, DocType=None, DocTitle=None, URL=None, XSLT=None, Paging=None, DeclearTimeFormat=None):
        if Filter is None:
            self.Filter = []
        else:
            self.Filter = Filter
        if MappingID is None:
            self.MappingID = []
        else:
            self.MappingID = MappingID
        self.DocType = DocType
        self.DocTitle = DocTitle
        self.URL = URL
        self.XSLT = XSLT
        self.Paging = Paging
        self.DeclearTimeFormat = DeclearTimeFormat
    def factory(*args_, **kwargs_):
        if StepType.subclass:
            return StepType.subclass(*args_, **kwargs_)
        else:
            return StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Filter(self): return self.Filter
    def set_Filter(self, Filter): self.Filter = Filter
    def add_Filter(self, value): self.Filter.append(value)
    def insert_Filter(self, index, value): self.Filter[index] = value
    def get_MappingID(self): return self.MappingID
    def set_MappingID(self, MappingID): self.MappingID = MappingID
    def add_MappingID(self, value): self.MappingID.append(value)
    def insert_MappingID(self, index, value): self.MappingID[index] = value
    def get_DocType(self): return self.DocType
    def set_DocType(self, DocType): self.DocType = DocType
    def get_DocTitle(self): return self.DocTitle
    def set_DocTitle(self, DocTitle): self.DocTitle = DocTitle
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_XSLT(self): return self.XSLT
    def set_XSLT(self, XSLT): self.XSLT = XSLT
    def get_Paging(self): return self.Paging
    def set_Paging(self, Paging): self.Paging = Paging
    def get_DeclearTimeFormat(self): return self.DeclearTimeFormat
    def set_DeclearTimeFormat(self, DeclearTimeFormat): self.DeclearTimeFormat = DeclearTimeFormat
    def export(self, outfile, level, namespace_='', name_='StepType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StepType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StepType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StepType', fromsubclass_=False):
        for Filter_ in self.Filter:
            Filter_.export(outfile, level, namespace_, name_='Filter')
        for MappingID_ in self.MappingID:
            MappingID_.export(outfile, level, namespace_, name_='MappingID')
        if self.DocType is not None:
            self.DocType.export(outfile, level, namespace_, name_='DocType', )
        if self.DocTitle is not None:
            showIndent(outfile, level)
            outfile.write('<%sDocTitle>%s</%sDocTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.DocTitle).encode(ExternalEncoding), input_name='DocTitle'), namespace_))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('<%sURL>%s</%sURL>\n' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_))
        if self.XSLT is not None:
            self.XSLT.export(outfile, level, namespace_, name_='XSLT', )
        if self.Paging is not None:
            self.Paging.export(outfile, level, namespace_, name_='Paging')
        if self.DeclearTimeFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDeclearTimeFormat>%s</%sDeclearTimeFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DeclearTimeFormat).encode(ExternalEncoding), input_name='DeclearTimeFormat'), namespace_))
    def hasContent_(self):
        if (
            self.Filter or
            self.MappingID or
            self.DocType is not None or
            self.DocTitle is not None or
            self.URL is not None or
            self.XSLT is not None or
            self.Paging is not None or
            self.DeclearTimeFormat is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StepType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Filter=[\n')
        level += 1
        for Filter_ in self.Filter:
            showIndent(outfile, level)
            outfile.write('model_.FilterType(\n')
            Filter_.exportLiteral(outfile, level, name_='FilterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MappingID=[\n')
        level += 1
        for MappingID_ in self.MappingID:
            showIndent(outfile, level)
            outfile.write('model_.MappingIDType(\n')
            MappingID_.exportLiteral(outfile, level, name_='MappingIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DocType is not None:
            showIndent(outfile, level)
            outfile.write('DocType=model_.DocTypeType(\n')
            self.DocType.exportLiteral(outfile, level, name_='DocType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocTitle is not None:
            showIndent(outfile, level)
            outfile.write('DocTitle=%s,\n' % quote_python(self.DocTitle).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.XSLT is not None:
            showIndent(outfile, level)
            outfile.write('XSLT=model_.XSLTType(\n')
            self.XSLT.exportLiteral(outfile, level, name_='XSLT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Paging is not None:
            showIndent(outfile, level)
            outfile.write('Paging=model_.PagingType(\n')
            self.Paging.exportLiteral(outfile, level, name_='Paging')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DeclearTimeFormat is not None:
            showIndent(outfile, level)
            outfile.write('DeclearTimeFormat=%s,\n' % quote_python(self.DeclearTimeFormat).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Filter':
            obj_ = FilterType.factory()
            obj_.build(child_)
            self.Filter.append(obj_)
        elif nodeName_ == 'MappingID':
            obj_ = MappingIDType.factory()
            obj_.build(child_)
            self.MappingID.append(obj_)
        elif nodeName_ == 'DocType':
            obj_ = DocTypeType.factory()
            obj_.build(child_)
            self.set_DocType(obj_)
        elif nodeName_ == 'DocTitle':
            DocTitle_ = child_.text
            DocTitle_ = self.gds_validate_string(DocTitle_, node, 'DocTitle')
            self.DocTitle = DocTitle_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'XSLT':
            obj_ = XSLTType.factory()
            obj_.build(child_)
            self.set_XSLT(obj_)
        elif nodeName_ == 'Paging':
            obj_ = PagingType.factory()
            obj_.build(child_)
            self.set_Paging(obj_)
        elif nodeName_ == 'DeclearTimeFormat':
            DeclearTimeFormat_ = child_.text
            DeclearTimeFormat_ = self.gds_validate_string(DeclearTimeFormat_, node, 'DeclearTimeFormat')
            self.DeclearTimeFormat = DeclearTimeFormat_
# end class StepType


class DocTitle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DocTitle.subclass:
            return DocTitle.subclass(*args_, **kwargs_)
        else:
            return DocTitle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DocTitle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTitle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocTitle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocTitle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocTitle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DocTitle


class DeclearTimeFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DeclearTimeFormat.subclass:
            return DeclearTimeFormat.subclass(*args_, **kwargs_)
        else:
            return DeclearTimeFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DeclearTimeFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeclearTimeFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeclearTimeFormat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeclearTimeFormat', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeclearTimeFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeclearTimeFormat


class FilterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SourceType=None, Operation=None, Value=None):
        self.SourceType = SourceType
        self.Operation = Operation
        self.Value = Value
    def factory(*args_, **kwargs_):
        if FilterType.subclass:
            return FilterType.subclass(*args_, **kwargs_)
        else:
            return FilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def get_Operation(self): return self.Operation
    def set_Operation(self, Operation): self.Operation = Operation
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='', name_='FilterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FilterType', fromsubclass_=False):
        if self.SourceType is not None:
            self.SourceType.export(outfile, level, namespace_, name_='SourceType', )
        if self.Operation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOperation>%s</%sOperation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Operation).encode(ExternalEncoding), input_name='Operation'), namespace_))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.SourceType is not None or
            self.Operation is not None or
            self.Value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SourceType is not None:
            showIndent(outfile, level)
            outfile.write('SourceType=model_.SourceType(\n')
            self.SourceType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Operation is not None:
            showIndent(outfile, level)
            outfile.write('Operation=%s,\n' % quote_python(self.Operation).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SourceType':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.set_SourceType(obj_)
        elif nodeName_ == 'Operation':
            Operation_ = child_.text
            Operation_ = self.gds_validate_string(Operation_, node, 'Operation')
            self.Operation = Operation_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class FilterType


class SourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if SourceType.subclass:
            return SourceType.subclass(*args_, **kwargs_)
        else:
            return SourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SourceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceType


class Operation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Operation.subclass:
            return Operation.subclass(*args_, **kwargs_)
        else:
            return Operation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Operation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Operation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Operation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Operation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Operation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Operation


class MappingIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MarketCode=None, DestinationTypes=None, Source=None):
        self.MarketCode = MarketCode
        self.DestinationTypes = DestinationTypes
        self.Source = Source
    def factory(*args_, **kwargs_):
        if MappingIDType.subclass:
            return MappingIDType.subclass(*args_, **kwargs_)
        else:
            return MappingIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MarketCode(self): return self.MarketCode
    def set_MarketCode(self, MarketCode): self.MarketCode = MarketCode
    def get_DestinationTypes(self): return self.DestinationTypes
    def set_DestinationTypes(self, DestinationTypes): self.DestinationTypes = DestinationTypes
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def export(self, outfile, level, namespace_='', name_='MappingIDType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MappingIDType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MappingIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MappingIDType', fromsubclass_=False):
        if self.MarketCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sMarketCode>%s</%sMarketCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.MarketCode).encode(ExternalEncoding), input_name='MarketCode'), namespace_))
        if self.DestinationTypes is not None:
            showIndent(outfile, level)
            outfile.write('<%sDestinationTypes>%s</%sDestinationTypes>\n' % (namespace_, self.gds_format_string(quote_xml(self.DestinationTypes).encode(ExternalEncoding), input_name='DestinationTypes'), namespace_))
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', )
    def hasContent_(self):
        if (
            self.MarketCode is not None or
            self.DestinationTypes is not None or
            self.Source is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MappingIDType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MarketCode is not None:
            showIndent(outfile, level)
            outfile.write('MarketCode=%s,\n' % quote_python(self.MarketCode).encode(ExternalEncoding))
        if self.DestinationTypes is not None:
            showIndent(outfile, level)
            outfile.write('DestinationTypes=%s,\n' % quote_python(self.DestinationTypes).encode(ExternalEncoding))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.SourceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MarketCode':
            MarketCode_ = child_.text
            MarketCode_ = self.gds_validate_string(MarketCode_, node, 'MarketCode')
            self.MarketCode = MarketCode_
        elif nodeName_ == 'DestinationTypes':
            DestinationTypes_ = child_.text
            DestinationTypes_ = self.gds_validate_string(DestinationTypes_, node, 'DestinationTypes')
            self.DestinationTypes = DestinationTypes_
        elif nodeName_ == 'Source':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.set_Source(obj_)
# end class MappingIDType


class MarketCode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if MarketCode.subclass:
            return MarketCode.subclass(*args_, **kwargs_)
        else:
            return MarketCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='MarketCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MarketCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MarketCode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MarketCode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MarketCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MarketCode


class DestinationTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DestinationTypes.subclass:
            return DestinationTypes.subclass(*args_, **kwargs_)
        else:
            return DestinationTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DestinationTypes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinationTypes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DestinationTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DestinationTypes', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DestinationTypes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DestinationTypes


class Pattern(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Pattern.subclass:
            return Pattern.subclass(*args_, **kwargs_)
        else:
            return Pattern(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Pattern', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pattern')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Pattern'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Pattern', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Pattern'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Pattern


class ValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Xpath=None, Title=None, DefaultValue=None):
        self.Xpath = Xpath
        self.Title = Title
        self.DefaultValue = DefaultValue
    def factory(*args_, **kwargs_):
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Xpath(self): return self.Xpath
    def set_Xpath(self, Xpath): self.Xpath = Xpath
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def export(self, outfile, level, namespace_='', name_='ValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValueType', fromsubclass_=False):
        if self.Xpath is not None:
            showIndent(outfile, level)
            outfile.write('<%sXpath>%s</%sXpath>\n' % (namespace_, self.gds_format_string(quote_xml(self.Xpath).encode(ExternalEncoding), input_name='Xpath'), namespace_))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitle>%s</%sTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_))
        if self.DefaultValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefaultValue>%s</%sDefaultValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), namespace_))
    def hasContent_(self):
        if (
            self.Xpath is not None or
            self.Title is not None or
            self.DefaultValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Xpath is not None:
            showIndent(outfile, level)
            outfile.write('Xpath=%s,\n' % quote_python(self.Xpath).encode(ExternalEncoding))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.DefaultValue is not None:
            showIndent(outfile, level)
            outfile.write('DefaultValue=%s,\n' % quote_python(self.DefaultValue).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Xpath':
            Xpath_ = child_.text
            Xpath_ = self.gds_validate_string(Xpath_, node, 'Xpath')
            self.Xpath = Xpath_
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'DefaultValue':
            DefaultValue_ = child_.text
            DefaultValue_ = self.gds_validate_string(DefaultValue_, node, 'DefaultValue')
            self.DefaultValue = DefaultValue_
# end class ValueType


class Xpath(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Xpath.subclass:
            return Xpath.subclass(*args_, **kwargs_)
        else:
            return Xpath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Xpath', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Xpath')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Xpath'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Xpath', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Xpath'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Xpath


class Title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Title.subclass:
            return Title.subclass(*args_, **kwargs_)
        else:
            return Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Title', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Title')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Title'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Title', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Title'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Title


class DefaultValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DefaultValue.subclass:
            return DefaultValue.subclass(*args_, **kwargs_)
        else:
            return DefaultValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DefaultValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultValue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefaultValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DefaultValue


class DocTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Default=None, Convert=None):
        self.Default = Default
        self.Convert = Convert
    def factory(*args_, **kwargs_):
        if DocTypeType.subclass:
            return DocTypeType.subclass(*args_, **kwargs_)
        else:
            return DocTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Default(self): return self.Default
    def set_Default(self, Default): self.Default = Default
    def get_Convert(self): return self.Convert
    def set_Convert(self, Convert): self.Convert = Convert
    def export(self, outfile, level, namespace_='', name_='DocTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTypeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocTypeType', fromsubclass_=False):
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefault>%s</%sDefault>\n' % (namespace_, self.gds_format_string(quote_xml(self.Default).encode(ExternalEncoding), input_name='Default'), namespace_))
        if self.Convert is not None:
            showIndent(outfile, level)
            outfile.write('<%sConvert>%s</%sConvert>\n' % (namespace_, self.gds_format_string(quote_xml(self.Convert).encode(ExternalEncoding), input_name='Convert'), namespace_))
    def hasContent_(self):
        if (
            self.Default is not None or
            self.Convert is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('Default=%s,\n' % quote_python(self.Default).encode(ExternalEncoding))
        if self.Convert is not None:
            showIndent(outfile, level)
            outfile.write('Convert=%s,\n' % quote_python(self.Convert).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Default':
            Default_ = child_.text
            Default_ = self.gds_validate_string(Default_, node, 'Default')
            self.Default = Default_
        elif nodeName_ == 'Convert':
            Convert_ = child_.text
            Convert_ = self.gds_validate_string(Convert_, node, 'Convert')
            self.Convert = Convert_
# end class DocTypeType


class Default(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Default.subclass:
            return Default.subclass(*args_, **kwargs_)
        else:
            return Default(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Default', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Default')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Default'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Default', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Default'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Default


class Convert(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Convert.subclass:
            return Convert.subclass(*args_, **kwargs_)
        else:
            return Convert(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Convert', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Convert')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Convert'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Convert', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Convert'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Convert


class XSLTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, XSLTFile=None, XSLTParams=None, XSLTFileURLExec=None):
        self.XSLTFile = XSLTFile
        self.XSLTParams = XSLTParams
        self.XSLTFileURLExec = XSLTFileURLExec
    def factory(*args_, **kwargs_):
        if XSLTType.subclass:
            return XSLTType.subclass(*args_, **kwargs_)
        else:
            return XSLTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XSLTFile(self): return self.XSLTFile
    def set_XSLTFile(self, XSLTFile): self.XSLTFile = XSLTFile
    def get_XSLTParams(self): return self.XSLTParams
    def set_XSLTParams(self, XSLTParams): self.XSLTParams = XSLTParams
    def get_XSLTFileURLExec(self): return self.XSLTFileURLExec
    def set_XSLTFileURLExec(self, XSLTFileURLExec): self.XSLTFileURLExec = XSLTFileURLExec
    def export(self, outfile, level, namespace_='', name_='XSLTType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XSLTType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XSLTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XSLTType', fromsubclass_=False):
        if self.XSLTFile is not None:
            showIndent(outfile, level)
            outfile.write('<%sXSLTFile>%s</%sXSLTFile>\n' % (namespace_, self.gds_format_string(quote_xml(self.XSLTFile).encode(ExternalEncoding), input_name='XSLTFile'), namespace_))
        if self.XSLTParams is not None:
            self.XSLTParams.export(outfile, level, namespace_, name_='XSLTParams')
        if self.XSLTFileURLExec is not None:
            self.XSLTFileURLExec.export(outfile, level, namespace_, name_='XSLTFileURLExec', )
    def hasContent_(self):
        if (
            self.XSLTFile is not None or
            self.XSLTParams is not None or
            self.XSLTFileURLExec is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XSLTType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.XSLTFile is not None:
            showIndent(outfile, level)
            outfile.write('XSLTFile=%s,\n' % quote_python(self.XSLTFile).encode(ExternalEncoding))
        if self.XSLTParams is not None:
            showIndent(outfile, level)
            outfile.write('XSLTParams=model_.XSLTParamsType(\n')
            self.XSLTParams.exportLiteral(outfile, level, name_='XSLTParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.XSLTFileURLExec is not None:
            showIndent(outfile, level)
            outfile.write('XSLTFileURLExec=model_.XSLTFileURLExecType(\n')
            self.XSLTFileURLExec.exportLiteral(outfile, level, name_='XSLTFileURLExec')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XSLTFile':
            XSLTFile_ = child_.text
            XSLTFile_ = self.gds_validate_string(XSLTFile_, node, 'XSLTFile')
            self.XSLTFile = XSLTFile_
        elif nodeName_ == 'XSLTParams':
            obj_ = XSLTParamsType.factory()
            obj_.build(child_)
            self.set_XSLTParams(obj_)
        elif nodeName_ == 'XSLTFileURLExec':
            obj_ = XSLTFileURLExecType.factory()
            obj_.build(child_)
            self.set_XSLTFileURLExec(obj_)
# end class XSLTType


class XSLTFile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if XSLTFile.subclass:
            return XSLTFile.subclass(*args_, **kwargs_)
        else:
            return XSLTFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='XSLTFile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XSLTFile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XSLTFile'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XSLTFile', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XSLTFile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class XSLTFile


class XSLTParamsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Param=None):
        if Param is None:
            self.Param = []
        else:
            self.Param = Param
    def factory(*args_, **kwargs_):
        if XSLTParamsType.subclass:
            return XSLTParamsType.subclass(*args_, **kwargs_)
        else:
            return XSLTParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Param(self): return self.Param
    def set_Param(self, Param): self.Param = Param
    def add_Param(self, value): self.Param.append(value)
    def insert_Param(self, index, value): self.Param[index] = value
    def export(self, outfile, level, namespace_='', name_='XSLTParamsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XSLTParamsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XSLTParamsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XSLTParamsType', fromsubclass_=False):
        for Param_ in self.Param:
            showIndent(outfile, level)
            outfile.write('<%sParam>%s</%sParam>\n' % (namespace_, self.gds_format_string(quote_xml(Param_).encode(ExternalEncoding), input_name='Param'), namespace_))
    def hasContent_(self):
        if (
            self.Param
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XSLTParamsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Param=[\n')
        level += 1
        for Param_ in self.Param:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Param_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Param':
            Param_ = child_.text
            Param_ = self.gds_validate_string(Param_, node, 'Param')
            self.Param.append(Param_)
# end class XSLTParamsType


class Param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Param.subclass:
            return Param.subclass(*args_, **kwargs_)
        else:
            return Param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Param', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Param')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Param'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Param', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Param'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Param


class XSLTFileURLExecType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExecType=None, ExecValue=None):
        self.ExecType = ExecType
        self.ExecValue = ExecValue
    def factory(*args_, **kwargs_):
        if XSLTFileURLExecType.subclass:
            return XSLTFileURLExecType.subclass(*args_, **kwargs_)
        else:
            return XSLTFileURLExecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExecType(self): return self.ExecType
    def set_ExecType(self, ExecType): self.ExecType = ExecType
    def get_ExecValue(self): return self.ExecValue
    def set_ExecValue(self, ExecValue): self.ExecValue = ExecValue
    def export(self, outfile, level, namespace_='', name_='XSLTFileURLExecType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XSLTFileURLExecType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XSLTFileURLExecType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XSLTFileURLExecType', fromsubclass_=False):
        if self.ExecType is not None:
            showIndent(outfile, level)
            outfile.write('<%sExecType>%s</%sExecType>\n' % (namespace_, self.gds_format_string(quote_xml(self.ExecType).encode(ExternalEncoding), input_name='ExecType'), namespace_))
        if self.ExecValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sExecValue>%s</%sExecValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.ExecValue).encode(ExternalEncoding), input_name='ExecValue'), namespace_))
    def hasContent_(self):
        if (
            self.ExecType is not None or
            self.ExecValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XSLTFileURLExecType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExecType is not None:
            showIndent(outfile, level)
            outfile.write('ExecType=%s,\n' % quote_python(self.ExecType).encode(ExternalEncoding))
        if self.ExecValue is not None:
            showIndent(outfile, level)
            outfile.write('ExecValue=%s,\n' % quote_python(self.ExecValue).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExecType':
            ExecType_ = child_.text
            ExecType_ = self.gds_validate_string(ExecType_, node, 'ExecType')
            self.ExecType = ExecType_
        elif nodeName_ == 'ExecValue':
            ExecValue_ = child_.text
            ExecValue_ = self.gds_validate_string(ExecValue_, node, 'ExecValue')
            self.ExecValue = ExecValue_
# end class XSLTFileURLExecType


class ExecType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ExecType.subclass:
            return ExecType.subclass(*args_, **kwargs_)
        else:
            return ExecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ExecType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExecType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExecType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExecType


class ExecValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ExecValue.subclass:
            return ExecValue.subclass(*args_, **kwargs_)
        else:
            return ExecValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ExecValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExecValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExecValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExecValue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExecValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ExecValue


class PagingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, JSFunc=None, PageNumberName=None):
        self.JSFunc = JSFunc
        self.PageNumberName = PageNumberName
    def factory(*args_, **kwargs_):
        if PagingType.subclass:
            return PagingType.subclass(*args_, **kwargs_)
        else:
            return PagingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_JSFunc(self): return self.JSFunc
    def set_JSFunc(self, JSFunc): self.JSFunc = JSFunc
    def get_PageNumberName(self): return self.PageNumberName
    def set_PageNumberName(self, PageNumberName): self.PageNumberName = PageNumberName
    def export(self, outfile, level, namespace_='', name_='PagingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PagingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PagingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PagingType', fromsubclass_=False):
        if self.JSFunc is not None:
            showIndent(outfile, level)
            outfile.write('<%sJSFunc>%s</%sJSFunc>\n' % (namespace_, self.gds_format_string(quote_xml(self.JSFunc).encode(ExternalEncoding), input_name='JSFunc'), namespace_))
        if self.PageNumberName is not None:
            showIndent(outfile, level)
            outfile.write('<%sPageNumberName>%s</%sPageNumberName>\n' % (namespace_, self.gds_format_string(quote_xml(self.PageNumberName).encode(ExternalEncoding), input_name='PageNumberName'), namespace_))
    def hasContent_(self):
        if (
            self.JSFunc is not None or
            self.PageNumberName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PagingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.JSFunc is not None:
            showIndent(outfile, level)
            outfile.write('JSFunc=%s,\n' % quote_python(self.JSFunc).encode(ExternalEncoding))
        if self.PageNumberName is not None:
            showIndent(outfile, level)
            outfile.write('PageNumberName=%s,\n' % quote_python(self.PageNumberName).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'JSFunc':
            JSFunc_ = child_.text
            JSFunc_ = self.gds_validate_string(JSFunc_, node, 'JSFunc')
            self.JSFunc = JSFunc_
        elif nodeName_ == 'PageNumberName':
            PageNumberName_ = child_.text
            PageNumberName_ = self.gds_validate_string(PageNumberName_, node, 'PageNumberName')
            self.PageNumberName = PageNumberName_
# end class PagingType


class JSFunc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if JSFunc.subclass:
            return JSFunc.subclass(*args_, **kwargs_)
        else:
            return JSFunc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='JSFunc', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JSFunc')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JSFunc'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JSFunc', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JSFunc'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class JSFunc


class PageNumberName(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if PageNumberName.subclass:
            return PageNumberName.subclass(*args_, **kwargs_)
        else:
            return PageNumberName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PageNumberName', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageNumberName')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageNumberName'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PageNumberName', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PageNumberName'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PageNumberName


class DatabaseSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DatabaseType=None, ConnectionString=None, DatabaseName=None, TableName=None, Sql=None, Macro=None, MonitorColumn=None, Delimiter=None):
        self.DatabaseType = DatabaseType
        self.ConnectionString = ConnectionString
        self.DatabaseName = DatabaseName
        self.TableName = TableName
        self.Sql = Sql
        self.Macro = Macro
        self.MonitorColumn = MonitorColumn
        self.Delimiter = Delimiter
    def factory(*args_, **kwargs_):
        if DatabaseSettingType.subclass:
            return DatabaseSettingType.subclass(*args_, **kwargs_)
        else:
            return DatabaseSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseType(self): return self.DatabaseType
    def set_DatabaseType(self, DatabaseType): self.DatabaseType = DatabaseType
    def get_ConnectionString(self): return self.ConnectionString
    def set_ConnectionString(self, ConnectionString): self.ConnectionString = ConnectionString
    def get_DatabaseName(self): return self.DatabaseName
    def set_DatabaseName(self, DatabaseName): self.DatabaseName = DatabaseName
    def get_TableName(self): return self.TableName
    def set_TableName(self, TableName): self.TableName = TableName
    def get_Sql(self): return self.Sql
    def set_Sql(self, Sql): self.Sql = Sql
    def get_Macro(self): return self.Macro
    def set_Macro(self, Macro): self.Macro = Macro
    def get_MonitorColumn(self): return self.MonitorColumn
    def set_MonitorColumn(self, MonitorColumn): self.MonitorColumn = MonitorColumn
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def export(self, outfile, level, namespace_='', name_='DatabaseSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseSettingType', fromsubclass_=False):
        if self.DatabaseType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDatabaseType>%s</%sDatabaseType>\n' % (namespace_, self.gds_format_string(quote_xml(self.DatabaseType).encode(ExternalEncoding), input_name='DatabaseType'), namespace_))
        if self.ConnectionString is not None:
            showIndent(outfile, level)
            outfile.write('<%sConnectionString>%s</%sConnectionString>\n' % (namespace_, self.gds_format_string(quote_xml(self.ConnectionString).encode(ExternalEncoding), input_name='ConnectionString'), namespace_))
        if self.DatabaseName is not None:
            showIndent(outfile, level)
            outfile.write('<%sDatabaseName>%s</%sDatabaseName>\n' % (namespace_, self.gds_format_string(quote_xml(self.DatabaseName).encode(ExternalEncoding), input_name='DatabaseName'), namespace_))
        if self.TableName is not None:
            showIndent(outfile, level)
            outfile.write('<%sTableName>%s</%sTableName>\n' % (namespace_, self.gds_format_string(quote_xml(self.TableName).encode(ExternalEncoding), input_name='TableName'), namespace_))
        if self.Sql is not None:
            self.Sql.export(outfile, level, namespace_, name_='Sql', )
        if self.Macro is not None:
            showIndent(outfile, level)
            outfile.write('<%sMacro>%s</%sMacro>\n' % (namespace_, self.gds_format_string(quote_xml(self.Macro).encode(ExternalEncoding), input_name='Macro'), namespace_))
        if self.MonitorColumn is not None:
            showIndent(outfile, level)
            outfile.write('<%sMonitorColumn>%s</%sMonitorColumn>\n' % (namespace_, self.gds_format_string(quote_xml(self.MonitorColumn).encode(ExternalEncoding), input_name='MonitorColumn'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
    def hasContent_(self):
        if (
            self.DatabaseType is not None or
            self.ConnectionString is not None or
            self.DatabaseName is not None or
            self.TableName is not None or
            self.Sql is not None or
            self.Macro is not None or
            self.MonitorColumn is not None or
            self.Delimiter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DatabaseSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DatabaseType is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseType=%s,\n' % quote_python(self.DatabaseType).encode(ExternalEncoding))
        if self.ConnectionString is not None:
            showIndent(outfile, level)
            outfile.write('ConnectionString=%s,\n' % quote_python(self.ConnectionString).encode(ExternalEncoding))
        if self.DatabaseName is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseName=%s,\n' % quote_python(self.DatabaseName).encode(ExternalEncoding))
        if self.TableName is not None:
            showIndent(outfile, level)
            outfile.write('TableName=%s,\n' % quote_python(self.TableName).encode(ExternalEncoding))
        if self.Sql is not None:
            showIndent(outfile, level)
            outfile.write('Sql=model_.SqlType(\n')
            self.Sql.exportLiteral(outfile, level, name_='Sql')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Macro is not None:
            showIndent(outfile, level)
            outfile.write('Macro=%s,\n' % quote_python(self.Macro).encode(ExternalEncoding))
        if self.MonitorColumn is not None:
            showIndent(outfile, level)
            outfile.write('MonitorColumn=%s,\n' % quote_python(self.MonitorColumn).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseType':
            DatabaseType_ = child_.text
            DatabaseType_ = self.gds_validate_string(DatabaseType_, node, 'DatabaseType')
            self.DatabaseType = DatabaseType_
        elif nodeName_ == 'ConnectionString':
            ConnectionString_ = child_.text
            ConnectionString_ = self.gds_validate_string(ConnectionString_, node, 'ConnectionString')
            self.ConnectionString = ConnectionString_
        elif nodeName_ == 'DatabaseName':
            DatabaseName_ = child_.text
            DatabaseName_ = self.gds_validate_string(DatabaseName_, node, 'DatabaseName')
            self.DatabaseName = DatabaseName_
        elif nodeName_ == 'TableName':
            TableName_ = child_.text
            TableName_ = self.gds_validate_string(TableName_, node, 'TableName')
            self.TableName = TableName_
        elif nodeName_ == 'Sql':
            obj_ = SqlType.factory()
            obj_.build(child_)
            self.set_Sql(obj_)
        elif nodeName_ == 'Macro':
            Macro_ = child_.text
            Macro_ = self.gds_validate_string(Macro_, node, 'Macro')
            self.Macro = Macro_
        elif nodeName_ == 'MonitorColumn':
            MonitorColumn_ = child_.text
            MonitorColumn_ = self.gds_validate_string(MonitorColumn_, node, 'MonitorColumn')
            self.MonitorColumn = MonitorColumn_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
# end class DatabaseSettingType


class DatabaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DatabaseType.subclass:
            return DatabaseType.subclass(*args_, **kwargs_)
        else:
            return DatabaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DatabaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DatabaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DatabaseType


class ConnectionString(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ConnectionString.subclass:
            return ConnectionString.subclass(*args_, **kwargs_)
        else:
            return ConnectionString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ConnectionString', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectionString')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectionString'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectionString', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConnectionString'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConnectionString


class DatabaseName(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DatabaseName.subclass:
            return DatabaseName.subclass(*args_, **kwargs_)
        else:
            return DatabaseName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DatabaseName', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseName')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseName'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseName', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DatabaseName'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DatabaseName


class TableName(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if TableName.subclass:
            return TableName.subclass(*args_, **kwargs_)
        else:
            return TableName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='TableName', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TableName')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TableName'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TableName', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TableName'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TableName


class Macro(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Macro.subclass:
            return Macro.subclass(*args_, **kwargs_)
        else:
            return Macro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Macro', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Macro')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Macro'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Macro', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Macro'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Macro


class MonitorColumn(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if MonitorColumn.subclass:
            return MonitorColumn.subclass(*args_, **kwargs_)
        else:
            return MonitorColumn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='MonitorColumn', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MonitorColumn')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MonitorColumn'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MonitorColumn', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MonitorColumn'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MonitorColumn


class SqlType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if SqlType.subclass:
            return SqlType.subclass(*args_, **kwargs_)
        else:
            return SqlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SqlType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SqlType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SqlType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SqlType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SqlType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SqlType


class LocalSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Path=None, FilenamePattern=None):
        self.Path = Path
        self.FilenamePattern = FilenamePattern
    def factory(*args_, **kwargs_):
        if LocalSettingType.subclass:
            return LocalSettingType.subclass(*args_, **kwargs_)
        else:
            return LocalSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_FilenamePattern(self): return self.FilenamePattern
    def set_FilenamePattern(self, FilenamePattern): self.FilenamePattern = FilenamePattern
    def export(self, outfile, level, namespace_='', name_='LocalSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalSettingType', fromsubclass_=False):
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('<%sPath>%s</%sPath>\n' % (namespace_, self.gds_format_string(quote_xml(self.Path).encode(ExternalEncoding), input_name='Path'), namespace_))
        if self.FilenamePattern is not None:
            showIndent(outfile, level)
            outfile.write('<%sFilenamePattern>%s</%sFilenamePattern>\n' % (namespace_, self.gds_format_string(quote_xml(self.FilenamePattern).encode(ExternalEncoding), input_name='FilenamePattern'), namespace_))
    def hasContent_(self):
        if (
            self.Path is not None or
            self.FilenamePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=%s,\n' % quote_python(self.Path).encode(ExternalEncoding))
        if self.FilenamePattern is not None:
            showIndent(outfile, level)
            outfile.write('FilenamePattern=%s,\n' % quote_python(self.FilenamePattern).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Path':
            Path_ = child_.text
            Path_ = self.gds_validate_string(Path_, node, 'Path')
            self.Path = Path_
        elif nodeName_ == 'FilenamePattern':
            FilenamePattern_ = child_.text
            FilenamePattern_ = self.gds_validate_string(FilenamePattern_, node, 'FilenamePattern')
            self.FilenamePattern = FilenamePattern_
# end class LocalSettingType


class Path(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Path.subclass:
            return Path.subclass(*args_, **kwargs_)
        else:
            return Path(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Path', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Path')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Path'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Path', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Path'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Path


class FilenamePattern(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if FilenamePattern.subclass:
            return FilenamePattern.subclass(*args_, **kwargs_)
        else:
            return FilenamePattern(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='FilenamePattern', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilenamePattern')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilenamePattern'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FilenamePattern', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilenamePattern'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FilenamePattern


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DownloadingConfig'
        rootClass = DownloadingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DownloadingConfig'
        rootClass = DownloadingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="DownloadingConfig",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DownloadingConfig'
        rootClass = DownloadingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from downloadingconfig import *\n\n')
    sys.stdout.write('import downloadingconfig as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ConnectionString",
    "Convert",
    "DatabaseName",
    "DatabaseSettingType",
    "DatabaseType",
    "DeclearTimeFormat",
    "Default",
    "DefaultValue",
    "Delimiter",
    "DestinationTypes",
    "DocCategory",
    "DocTitle",
    "DocTypeType",
    "DownloadingConfig",
    "Encoding",
    "EndDateType",
    "EndTime",
    "ExecType",
    "ExecValue",
    "FilenamePattern",
    "FilterType",
    "Frequency",
    "JSFunc",
    "LocalSettingType",
    "Macro",
    "MappingIDType",
    "MarketCode",
    "MonitorColumn",
    "Operation",
    "PageNumberName",
    "PagingType",
    "Param",
    "ParseSolution",
    "Path",
    "Pattern",
    "PeriodType",
    "SearchByDateTypeType",
    "SourceType",
    "SqlType",
    "StartDateType",
    "StartTime",
    "StepType",
    "Structe",
    "TableName",
    "Title",
    "Type",
    "URL",
    "Value",
    "ValueType",
    "WebSettingType",
    "XSLTFile",
    "XSLTFileURLExecType",
    "XSLTParamsType",
    "XSLTType",
    "Xpath"
    ]
