#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Nov 09 16:04:49 2011 by generateDS.py version 2.7a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class DownloadingConfig(GeneratedsSuper):
    """Comment describing your root element"""
    subclass = None
    superclass = None
    def __init__(self, StartTime=None, EndTime=None, Frequency=None, DocCategory=None, WebSetting=None, DatabaseSetting=None, LocalSetting=None):
        self.StartTime = StartTime
        self.EndTime = EndTime
        self.Frequency = Frequency
        self.DocCategory = DocCategory
        self.WebSetting = WebSetting
        self.DatabaseSetting = DatabaseSetting
        self.LocalSetting = LocalSetting
    def factory(*args_, **kwargs_):
        if DownloadingConfig.subclass:
            return DownloadingConfig.subclass(*args_, **kwargs_)
        else:
            return DownloadingConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_Frequency(self): return self.Frequency
    def set_Frequency(self, Frequency): self.Frequency = Frequency
    def get_DocCategory(self): return self.DocCategory
    def set_DocCategory(self, DocCategory): self.DocCategory = DocCategory
    def get_WebSetting(self): return self.WebSetting
    def set_WebSetting(self, WebSetting): self.WebSetting = WebSetting
    def get_DatabaseSetting(self): return self.DatabaseSetting
    def set_DatabaseSetting(self, DatabaseSetting): self.DatabaseSetting = DatabaseSetting
    def get_LocalSetting(self): return self.LocalSetting
    def set_LocalSetting(self, LocalSetting): self.LocalSetting = LocalSetting
    def export(self, outfile, level, namespace_='', name_='DownloadingConfig', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DownloadingConfig')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DownloadingConfig'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DownloadingConfig', fromsubclass_=False):
        if self.StartTime is not None:
            self.StartTime.export(outfile, level, namespace_, name_='StartTime', )
        if self.EndTime is not None:
            self.EndTime.export(outfile, level, namespace_, name_='EndTime', )
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('<%sFrequency>%s</%sFrequency>\n' % (namespace_, self.gds_format_integer(self.Frequency, input_name='Frequency'), namespace_))
        if self.DocCategory is not None:
            showIndent(outfile, level)
            outfile.write('<%sDocCategory>%s</%sDocCategory>\n' % (namespace_, self.gds_format_string(quote_xml(self.DocCategory).encode(ExternalEncoding), input_name='DocCategory'), namespace_))
        if self.WebSetting is not None:
            self.WebSetting.export(outfile, level, namespace_, name_='WebSetting')
        if self.DatabaseSetting is not None:
            self.DatabaseSetting.export(outfile, level, namespace_, name_='DatabaseSetting')
        if self.LocalSetting is not None:
            self.LocalSetting.export(outfile, level, namespace_, name_='LocalSetting')
    def hasContent_(self):
        if (
            self.StartTime is not None or
            self.EndTime is not None or
            self.Frequency is not None or
            self.DocCategory is not None or
            self.WebSetting is not None or
            self.DatabaseSetting is not None or
            self.LocalSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DownloadingConfig'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=model_.xs_time(\n')
            self.StartTime.exportLiteral(outfile, level, name_='StartTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=model_.xs_time(\n')
            self.EndTime.exportLiteral(outfile, level, name_='EndTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Frequency is not None:
            showIndent(outfile, level)
            outfile.write('Frequency=%d,\n' % self.Frequency)
        if self.DocCategory is not None:
            showIndent(outfile, level)
            outfile.write('DocCategory=%s,\n' % quote_python(self.DocCategory).encode(ExternalEncoding))
        if self.WebSetting is not None:
            showIndent(outfile, level)
            outfile.write('WebSetting=model_.WebSettingType(\n')
            self.WebSetting.exportLiteral(outfile, level, name_='WebSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DatabaseSetting is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseSetting=model_.DatabaseSettingType(\n')
            self.DatabaseSetting.exportLiteral(outfile, level, name_='DatabaseSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalSetting is not None:
            showIndent(outfile, level)
            outfile.write('LocalSetting=model_.LocalSettingType(\n')
            self.LocalSetting.exportLiteral(outfile, level, name_='LocalSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartTime':
            obj_ = xs_time.factory()
            obj_.build(child_)
            self.set_StartTime(obj_)
        elif nodeName_ == 'EndTime':
            obj_ = xs_time.factory()
            obj_.build(child_)
            self.set_EndTime(obj_)
        elif nodeName_ == 'Frequency':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Frequency')
            self.Frequency = ival_
        elif nodeName_ == 'DocCategory':
            DocCategory_ = child_.text
            DocCategory_ = self.gds_validate_string(DocCategory_, node, 'DocCategory')
            self.DocCategory = DocCategory_
        elif nodeName_ == 'WebSetting':
            obj_ = WebSettingType.factory()
            obj_.build(child_)
            self.set_WebSetting(obj_)
        elif nodeName_ == 'DatabaseSetting':
            obj_ = DatabaseSettingType.factory()
            obj_.build(child_)
            self.set_DatabaseSetting(obj_)
        elif nodeName_ == 'LocalSetting':
            obj_ = LocalSettingType.factory()
            obj_.build(child_)
            self.set_LocalSetting(obj_)
# end class DownloadingConfig


class DatePoint(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DateType=None, Date=None, DateValue=None, DateUnit=None):
        self.DateType = DateType
        self.Date = Date
        self.DateValue = DateValue
        self.DateUnit = DateUnit
    def factory(*args_, **kwargs_):
        if DatePoint.subclass:
            return DatePoint.subclass(*args_, **kwargs_)
        else:
            return DatePoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateType(self): return self.DateType
    def set_DateType(self, DateType): self.DateType = DateType
    def validate_DateType(self, value):
        # Validate type DateType, a restriction on xs:string.
        pass
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_DateValue(self): return self.DateValue
    def set_DateValue(self, DateValue): self.DateValue = DateValue
    def validate_DateValue(self, value):
        # Validate type DateValue, a restriction on xs:integer.
        pass
    def get_DateUnit(self): return self.DateUnit
    def set_DateUnit(self, DateUnit): self.DateUnit = DateUnit
    def export(self, outfile, level, namespace_='', name_='DatePoint', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatePoint')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatePoint'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatePoint', fromsubclass_=False):
        if self.DateType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateType>%s</%sDateType>\n' % (namespace_, self.gds_format_string(quote_xml(self.DateType).encode(ExternalEncoding), input_name='DateType'), namespace_))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('<%sDate>%s</%sDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_))
        if self.DateValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateValue>%s</%sDateValue>\n' % (namespace_, self.gds_format_integer(self.DateValue, input_name='DateValue'), namespace_))
        if self.DateUnit is not None:
            showIndent(outfile, level)
            outfile.write('<%sDateUnit>%s</%sDateUnit>\n' % (namespace_, self.gds_format_integer(self.DateUnit, input_name='DateUnit'), namespace_))
    def hasContent_(self):
        if (
            self.DateType is not None or
            self.Date is not None or
            self.DateValue is not None or
            self.DateUnit is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DatePoint'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DateType is not None:
            showIndent(outfile, level)
            outfile.write('DateType=%s,\n' % quote_python(self.DateType).encode(ExternalEncoding))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
        if self.DateValue is not None:
            showIndent(outfile, level)
            outfile.write('DateValue=%d,\n' % self.DateValue)
        if self.DateUnit is not None:
            showIndent(outfile, level)
            outfile.write('DateUnit=%d,\n' % self.DateUnit)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateType':
            DateType_ = child_.text
            DateType_ = self.gds_validate_string(DateType_, node, 'DateType')
            self.DateType = DateType_
            self.validate_DateType(self.DateType)    # validate type DateType
        elif nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'DateValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DateValue')
            self.DateValue = ival_
            self.validate_DateValue(self.DateValue)    # validate type DateValue
        elif nodeName_ == 'DateUnit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DateUnit')
            self.DateUnit = ival_
            self.validate_DateValue(self.DateUnit)    # validate type DateValue
# end class DatePoint


class DateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DateType.subclass:
            return DateType.subclass(*args_, **kwargs_)
        else:
            return DateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DateType


class OperationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if OperationType.subclass:
            return OperationType.subclass(*args_, **kwargs_)
        else:
            return OperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='OperationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='OperationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OperationType


class WebSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, URL=None, Encoding=None, Structe=None, Delimiter=None, Period=None, SearchDateType=None, Step=None):
        self.URL = URL
        self.Encoding = Encoding
        self.Structe = Structe
        self.Delimiter = Delimiter
        self.Period = Period
        self.SearchDateType = SearchDateType
        self.Step = Step
    def factory(*args_, **kwargs_):
        if WebSettingType.subclass:
            return WebSettingType.subclass(*args_, **kwargs_)
        else:
            return WebSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def get_Structe(self): return self.Structe
    def set_Structe(self, Structe): self.Structe = Structe
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_Period(self): return self.Period
    def set_Period(self, Period): self.Period = Period
    def get_SearchDateType(self): return self.SearchDateType
    def set_SearchDateType(self, SearchDateType): self.SearchDateType = SearchDateType
    def validate_DateUnit(self, value):
        # Validate type DateUnit, a restriction on xs:string.
        pass
    def get_Step(self): return self.Step
    def set_Step(self, Step): self.Step = Step
    def export(self, outfile, level, namespace_='', name_='WebSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WebSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WebSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WebSettingType', fromsubclass_=False):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('<%sURL>%s</%sURL>\n' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_))
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('<%sEncoding>%s</%sEncoding>\n' % (namespace_, self.gds_format_string(quote_xml(self.Encoding).encode(ExternalEncoding), input_name='Encoding'), namespace_))
        if self.Structe is not None:
            showIndent(outfile, level)
            outfile.write('<%sStructe>%s</%sStructe>\n' % (namespace_, self.gds_format_string(quote_xml(self.Structe).encode(ExternalEncoding), input_name='Structe'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
        if self.Period is not None:
            self.Period.export(outfile, level, namespace_, name_='Period', )
        if self.SearchDateType is not None:
            showIndent(outfile, level)
            outfile.write('<%sSearchDateType>%s</%sSearchDateType>\n' % (namespace_, self.gds_format_string(quote_xml(self.SearchDateType).encode(ExternalEncoding), input_name='SearchDateType'), namespace_))
        if self.Step is not None:
            self.Step.export(outfile, level, namespace_, name_='Step', )
    def hasContent_(self):
        if (
            self.URL is not None or
            self.Encoding is not None or
            self.Structe is not None or
            self.Delimiter is not None or
            self.Period is not None or
            self.SearchDateType is not None or
            self.Step is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WebSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Encoding=%s,\n' % quote_python(self.Encoding).encode(ExternalEncoding))
        if self.Structe is not None:
            showIndent(outfile, level)
            outfile.write('Structe=%s,\n' % quote_python(self.Structe).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
        if self.Period is not None:
            showIndent(outfile, level)
            outfile.write('Period=model_.PeriodType(\n')
            self.Period.exportLiteral(outfile, level, name_='Period')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SearchDateType is not None:
            showIndent(outfile, level)
            outfile.write('SearchDateType=%s,\n' % quote_python(self.SearchDateType).encode(ExternalEncoding))
        if self.Step is not None:
            showIndent(outfile, level)
            outfile.write('Step=model_.StepType(\n')
            self.Step.exportLiteral(outfile, level, name_='Step')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'Encoding':
            Encoding_ = child_.text
            Encoding_ = self.gds_validate_string(Encoding_, node, 'Encoding')
            self.Encoding = Encoding_
        elif nodeName_ == 'Structe':
            Structe_ = child_.text
            Structe_ = self.gds_validate_string(Structe_, node, 'Structe')
            self.Structe = Structe_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
        elif nodeName_ == 'Period':
            obj_ = PeriodType.factory()
            obj_.build(child_)
            self.set_Period(obj_)
        elif nodeName_ == 'SearchDateType':
            SearchDateType_ = child_.text
            SearchDateType_ = self.gds_validate_string(SearchDateType_, node, 'SearchDateType')
            self.SearchDateType = SearchDateType_
            self.validate_DateUnit(self.SearchDateType)    # validate type DateUnit
        elif nodeName_ == 'Step':
            obj_ = StepType.factory()
            obj_.build(child_)
            self.set_Step(obj_)
# end class WebSettingType


class Encoding(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Encoding.subclass:
            return Encoding.subclass(*args_, **kwargs_)
        else:
            return Encoding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Encoding', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Encoding')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Encoding'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Encoding', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Encoding'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Encoding


class Structe(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Structe.subclass:
            return Structe.subclass(*args_, **kwargs_)
        else:
            return Structe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Structe', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Structe')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Structe'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Structe', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Structe'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Structe


class Delimiter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Delimiter.subclass:
            return Delimiter.subclass(*args_, **kwargs_)
        else:
            return Delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Delimiter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Delimiter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Delimiter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Delimiter', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Delimiter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Delimiter


class PeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartDate=None, EndDate=None):
        self.StartDate = StartDate
        self.EndDate = EndDate
    def factory(*args_, **kwargs_):
        if PeriodType.subclass:
            return PeriodType.subclass(*args_, **kwargs_)
        else:
            return PeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def export(self, outfile, level, namespace_='', name_='PeriodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PeriodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PeriodType', fromsubclass_=False):
        if self.StartDate is not None:
            self.StartDate.export(outfile, level, namespace_, name_='StartDate', )
        if self.EndDate is not None:
            self.EndDate.export(outfile, level, namespace_, name_='EndDate', )
    def hasContent_(self):
        if (
            self.StartDate is not None or
            self.EndDate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PeriodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartDate is not None:
            showIndent(outfile, level)
            outfile.write('StartDate=model_.DatePoint(\n')
            self.StartDate.exportLiteral(outfile, level, name_='StartDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=model_.DatePoint(\n')
            self.EndDate.exportLiteral(outfile, level, name_='EndDate')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartDate':
            obj_ = DatePoint.factory()
            obj_.build(child_)
            self.set_StartDate(obj_)
        elif nodeName_ == 'EndDate':
            obj_ = DatePoint.factory()
            obj_.build(child_)
            self.set_EndDate(obj_)
# end class PeriodType


class StepType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ParseSolution=None, Filter=None, MappingID=None, DocType=None, DocTitleIndex=None, DeclearTimeFormat=None, URL=None, XSLT=None, Paging=None):
        self.ParseSolution = ParseSolution
        if Filter is None:
            self.Filter = []
        else:
            self.Filter = Filter
        if MappingID is None:
            self.MappingID = []
        else:
            self.MappingID = MappingID
        self.DocType = DocType
        self.DocTitleIndex = DocTitleIndex
        self.DeclearTimeFormat = DeclearTimeFormat
        self.URL = URL
        self.XSLT = XSLT
        self.Paging = Paging
    def factory(*args_, **kwargs_):
        if StepType.subclass:
            return StepType.subclass(*args_, **kwargs_)
        else:
            return StepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParseSolution(self): return self.ParseSolution
    def set_ParseSolution(self, ParseSolution): self.ParseSolution = ParseSolution
    def get_Filter(self): return self.Filter
    def set_Filter(self, Filter): self.Filter = Filter
    def add_Filter(self, value): self.Filter.append(value)
    def insert_Filter(self, index, value): self.Filter[index] = value
    def get_MappingID(self): return self.MappingID
    def set_MappingID(self, MappingID): self.MappingID = MappingID
    def add_MappingID(self, value): self.MappingID.append(value)
    def insert_MappingID(self, index, value): self.MappingID[index] = value
    def get_DocType(self): return self.DocType
    def set_DocType(self, DocType): self.DocType = DocType
    def get_DocTitleIndex(self): return self.DocTitleIndex
    def set_DocTitleIndex(self, DocTitleIndex): self.DocTitleIndex = DocTitleIndex
    def get_DeclearTimeFormat(self): return self.DeclearTimeFormat
    def set_DeclearTimeFormat(self, DeclearTimeFormat): self.DeclearTimeFormat = DeclearTimeFormat
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def get_XSLT(self): return self.XSLT
    def set_XSLT(self, XSLT): self.XSLT = XSLT
    def get_Paging(self): return self.Paging
    def set_Paging(self, Paging): self.Paging = Paging
    def export(self, outfile, level, namespace_='', name_='StepType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StepType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StepType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StepType', fromsubclass_=False):
        if self.ParseSolution is not None:
            showIndent(outfile, level)
            outfile.write('<%sParseSolution>%s</%sParseSolution>\n' % (namespace_, self.gds_format_string(quote_xml(self.ParseSolution).encode(ExternalEncoding), input_name='ParseSolution'), namespace_))
        for Filter_ in self.Filter:
            Filter_.export(outfile, level, namespace_, name_='Filter')
        for MappingID_ in self.MappingID:
            MappingID_.export(outfile, level, namespace_, name_='MappingID')
        if self.DocType is not None:
            self.DocType.export(outfile, level, namespace_, name_='DocType')
        if self.DocTitleIndex is not None:
            showIndent(outfile, level)
            outfile.write('<%sDocTitleIndex>%s</%sDocTitleIndex>\n' % (namespace_, self.gds_format_integer(self.DocTitleIndex, input_name='DocTitleIndex'), namespace_))
        if self.DeclearTimeFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDeclearTimeFormat>%s</%sDeclearTimeFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DeclearTimeFormat).encode(ExternalEncoding), input_name='DeclearTimeFormat'), namespace_))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('<%sURL>%s</%sURL>\n' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_))
        if self.XSLT is not None:
            self.XSLT.export(outfile, level, namespace_, name_='XSLT', )
        if self.Paging is not None:
            self.Paging.export(outfile, level, namespace_, name_='Paging')
    def hasContent_(self):
        if (
            self.ParseSolution is not None or
            self.Filter or
            self.MappingID or
            self.DocType is not None or
            self.DocTitleIndex is not None or
            self.DeclearTimeFormat is not None or
            self.URL is not None or
            self.XSLT is not None or
            self.Paging is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StepType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ParseSolution is not None:
            showIndent(outfile, level)
            outfile.write('ParseSolution=%s,\n' % quote_python(self.ParseSolution).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Filter=[\n')
        level += 1
        for Filter_ in self.Filter:
            showIndent(outfile, level)
            outfile.write('model_.FilterType(\n')
            Filter_.exportLiteral(outfile, level, name_='FilterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MappingID=[\n')
        level += 1
        for MappingID_ in self.MappingID:
            showIndent(outfile, level)
            outfile.write('model_.MappingIDType(\n')
            MappingID_.exportLiteral(outfile, level, name_='MappingIDType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DocType is not None:
            showIndent(outfile, level)
            outfile.write('DocType=model_.DocTypeType(\n')
            self.DocType.exportLiteral(outfile, level, name_='DocType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DocTitleIndex is not None:
            showIndent(outfile, level)
            outfile.write('DocTitleIndex=%d,\n' % self.DocTitleIndex)
        if self.DeclearTimeFormat is not None:
            showIndent(outfile, level)
            outfile.write('DeclearTimeFormat=%s,\n' % quote_python(self.DeclearTimeFormat).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
        if self.XSLT is not None:
            showIndent(outfile, level)
            outfile.write('XSLT=model_.XSLTType(\n')
            self.XSLT.exportLiteral(outfile, level, name_='XSLT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Paging is not None:
            showIndent(outfile, level)
            outfile.write('Paging=model_.PagingType(\n')
            self.Paging.exportLiteral(outfile, level, name_='Paging')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParseSolution':
            ParseSolution_ = child_.text
            ParseSolution_ = self.gds_validate_string(ParseSolution_, node, 'ParseSolution')
            self.ParseSolution = ParseSolution_
        elif nodeName_ == 'Filter':
            obj_ = FilterType.factory()
            obj_.build(child_)
            self.Filter.append(obj_)
        elif nodeName_ == 'MappingID':
            obj_ = MappingIDType.factory()
            obj_.build(child_)
            self.MappingID.append(obj_)
        elif nodeName_ == 'DocType':
            obj_ = DocTypeType.factory()
            obj_.build(child_)
            self.set_DocType(obj_)
        elif nodeName_ == 'DocTitleIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DocTitleIndex')
            self.DocTitleIndex = ival_
        elif nodeName_ == 'DeclearTimeFormat':
            DeclearTimeFormat_ = child_.text
            DeclearTimeFormat_ = self.gds_validate_string(DeclearTimeFormat_, node, 'DeclearTimeFormat')
            self.DeclearTimeFormat = DeclearTimeFormat_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
        elif nodeName_ == 'XSLT':
            obj_ = XSLTType.factory()
            obj_.build(child_)
            self.set_XSLT(obj_)
        elif nodeName_ == 'Paging':
            obj_ = PagingType.factory()
            obj_.build(child_)
            self.set_Paging(obj_)
# end class StepType


class ParseSolution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ParseSolution.subclass:
            return ParseSolution.subclass(*args_, **kwargs_)
        else:
            return ParseSolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ParseSolution', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParseSolution')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParseSolution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParseSolution', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParseSolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParseSolution


class DeclearTimeFormat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DeclearTimeFormat.subclass:
            return DeclearTimeFormat.subclass(*args_, **kwargs_)
        else:
            return DeclearTimeFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DeclearTimeFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeclearTimeFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeclearTimeFormat'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeclearTimeFormat', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeclearTimeFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeclearTimeFormat


class FilterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SourceType=None, Operation=None, Value=None):
        self.SourceType = SourceType
        self.Operation = Operation
        self.Value = Value
    def factory(*args_, **kwargs_):
        if FilterType.subclass:
            return FilterType.subclass(*args_, **kwargs_)
        else:
            return FilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SourceType(self): return self.SourceType
    def set_SourceType(self, SourceType): self.SourceType = SourceType
    def get_Operation(self): return self.Operation
    def set_Operation(self, Operation): self.Operation = Operation
    def validate_OperationType(self, value):
        # Validate type OperationType, a restriction on xs:string.
        pass
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def export(self, outfile, level, namespace_='', name_='FilterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilterType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FilterType', fromsubclass_=False):
        if self.SourceType is not None:
            showIndent(outfile, level)
            outfile.write('<%sSourceType>%s</%sSourceType>\n' % (namespace_, self.gds_format_string(quote_xml(self.SourceType).encode(ExternalEncoding), input_name='SourceType'), namespace_))
        if self.Operation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOperation>%s</%sOperation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Operation).encode(ExternalEncoding), input_name='Operation'), namespace_))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('<%sValue>%s</%sValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_))
    def hasContent_(self):
        if (
            self.SourceType is not None or
            self.Operation is not None or
            self.Value is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SourceType is not None:
            showIndent(outfile, level)
            outfile.write('SourceType=%s,\n' % quote_python(self.SourceType).encode(ExternalEncoding))
        if self.Operation is not None:
            showIndent(outfile, level)
            outfile.write('Operation=%s,\n' % quote_python(self.Operation).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SourceType':
            SourceType_ = child_.text
            SourceType_ = self.gds_validate_string(SourceType_, node, 'SourceType')
            self.SourceType = SourceType_
        elif nodeName_ == 'Operation':
            Operation_ = child_.text
            Operation_ = self.gds_validate_string(Operation_, node, 'Operation')
            self.Operation = Operation_
            self.validate_OperationType(self.Operation)    # validate type OperationType
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class FilterType


class SourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if SourceType.subclass:
            return SourceType.subclass(*args_, **kwargs_)
        else:
            return SourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='SourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SourceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SourceType


class Value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Value', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Value')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Value'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Value', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Value'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Value


class MappingIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MarketCode=None, DestinationTypes=None, Source=None):
        self.MarketCode = MarketCode
        self.DestinationTypes = DestinationTypes
        self.Source = Source
    def factory(*args_, **kwargs_):
        if MappingIDType.subclass:
            return MappingIDType.subclass(*args_, **kwargs_)
        else:
            return MappingIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MarketCode(self): return self.MarketCode
    def set_MarketCode(self, MarketCode): self.MarketCode = MarketCode
    def get_DestinationTypes(self): return self.DestinationTypes
    def set_DestinationTypes(self, DestinationTypes): self.DestinationTypes = DestinationTypes
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def validate_SourceType(self, value):
        # Validate type SourceType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='MappingIDType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MappingIDType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MappingIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MappingIDType', fromsubclass_=False):
        if self.MarketCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sMarketCode>%s</%sMarketCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.MarketCode).encode(ExternalEncoding), input_name='MarketCode'), namespace_))
        if self.DestinationTypes is not None:
            showIndent(outfile, level)
            outfile.write('<%sDestinationTypes>%s</%sDestinationTypes>\n' % (namespace_, self.gds_format_string(quote_xml(self.DestinationTypes).encode(ExternalEncoding), input_name='DestinationTypes'), namespace_))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('<%sSource>%s</%sSource>\n' % (namespace_, self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), namespace_))
    def hasContent_(self):
        if (
            self.MarketCode is not None or
            self.DestinationTypes is not None or
            self.Source is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MappingIDType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MarketCode is not None:
            showIndent(outfile, level)
            outfile.write('MarketCode=%s,\n' % quote_python(self.MarketCode).encode(ExternalEncoding))
        if self.DestinationTypes is not None:
            showIndent(outfile, level)
            outfile.write('DestinationTypes=%s,\n' % quote_python(self.DestinationTypes).encode(ExternalEncoding))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=%s,\n' % quote_python(self.Source).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MarketCode':
            MarketCode_ = child_.text
            MarketCode_ = self.gds_validate_string(MarketCode_, node, 'MarketCode')
            self.MarketCode = MarketCode_
        elif nodeName_ == 'DestinationTypes':
            DestinationTypes_ = child_.text
            DestinationTypes_ = self.gds_validate_string(DestinationTypes_, node, 'DestinationTypes')
            self.DestinationTypes = DestinationTypes_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
            self.validate_SourceType(self.Source)    # validate type SourceType
# end class MappingIDType


class MarketCode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if MarketCode.subclass:
            return MarketCode.subclass(*args_, **kwargs_)
        else:
            return MarketCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='MarketCode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MarketCode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MarketCode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MarketCode', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MarketCode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MarketCode


class DestinationTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DestinationTypes.subclass:
            return DestinationTypes.subclass(*args_, **kwargs_)
        else:
            return DestinationTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DestinationTypes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinationTypes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DestinationTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DestinationTypes', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DestinationTypes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DestinationTypes


class Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Type.subclass:
            return Type.subclass(*args_, **kwargs_)
        else:
            return Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Type', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Type')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Type', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Type'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Type


class Pattern(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Pattern.subclass:
            return Pattern.subclass(*args_, **kwargs_)
        else:
            return Pattern(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Pattern', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pattern')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Pattern'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Pattern', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Pattern'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Pattern


class ValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Xpath=None, Title=None, DefaultValue=None):
        self.Xpath = Xpath
        self.Title = Title
        self.DefaultValue = DefaultValue
    def factory(*args_, **kwargs_):
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Xpath(self): return self.Xpath
    def set_Xpath(self, Xpath): self.Xpath = Xpath
    def get_Title(self): return self.Title
    def set_Title(self, Title): self.Title = Title
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def export(self, outfile, level, namespace_='', name_='ValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValueType', fromsubclass_=False):
        if self.Xpath is not None:
            showIndent(outfile, level)
            outfile.write('<%sXpath>%s</%sXpath>\n' % (namespace_, self.gds_format_string(quote_xml(self.Xpath).encode(ExternalEncoding), input_name='Xpath'), namespace_))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('<%sTitle>%s</%sTitle>\n' % (namespace_, self.gds_format_string(quote_xml(self.Title).encode(ExternalEncoding), input_name='Title'), namespace_))
        if self.DefaultValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefaultValue>%s</%sDefaultValue>\n' % (namespace_, self.gds_format_string(quote_xml(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), namespace_))
    def hasContent_(self):
        if (
            self.Xpath is not None or
            self.Title is not None or
            self.DefaultValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Xpath is not None:
            showIndent(outfile, level)
            outfile.write('Xpath=%s,\n' % quote_python(self.Xpath).encode(ExternalEncoding))
        if self.Title is not None:
            showIndent(outfile, level)
            outfile.write('Title=%s,\n' % quote_python(self.Title).encode(ExternalEncoding))
        if self.DefaultValue is not None:
            showIndent(outfile, level)
            outfile.write('DefaultValue=%s,\n' % quote_python(self.DefaultValue).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Xpath':
            Xpath_ = child_.text
            Xpath_ = self.gds_validate_string(Xpath_, node, 'Xpath')
            self.Xpath = Xpath_
        elif nodeName_ == 'Title':
            Title_ = child_.text
            Title_ = self.gds_validate_string(Title_, node, 'Title')
            self.Title = Title_
        elif nodeName_ == 'DefaultValue':
            DefaultValue_ = child_.text
            DefaultValue_ = self.gds_validate_string(DefaultValue_, node, 'DefaultValue')
            self.DefaultValue = DefaultValue_
# end class ValueType


class Xpath(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Xpath.subclass:
            return Xpath.subclass(*args_, **kwargs_)
        else:
            return Xpath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Xpath', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Xpath')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Xpath'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Xpath', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Xpath'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Xpath


class Title(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Title.subclass:
            return Title.subclass(*args_, **kwargs_)
        else:
            return Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Title', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Title')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Title'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Title', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Title'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Title


class DefaultValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DefaultValue.subclass:
            return DefaultValue.subclass(*args_, **kwargs_)
        else:
            return DefaultValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DefaultValue', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultValue')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultValue'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultValue', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefaultValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DefaultValue


class DocTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Default=None, Convert=None):
        self.Default = Default
        self.Convert = Convert
    def factory(*args_, **kwargs_):
        if DocTypeType.subclass:
            return DocTypeType.subclass(*args_, **kwargs_)
        else:
            return DocTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Default(self): return self.Default
    def set_Default(self, Default): self.Default = Default
    def get_Convert(self): return self.Convert
    def set_Convert(self, Convert): self.Convert = Convert
    def export(self, outfile, level, namespace_='', name_='DocTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DocTypeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DocTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DocTypeType', fromsubclass_=False):
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefault>%s</%sDefault>\n' % (namespace_, self.gds_format_string(quote_xml(self.Default).encode(ExternalEncoding), input_name='Default'), namespace_))
        if self.Convert is not None:
            showIndent(outfile, level)
            outfile.write('<%sConvert>%s</%sConvert>\n' % (namespace_, self.gds_format_string(quote_xml(self.Convert).encode(ExternalEncoding), input_name='Convert'), namespace_))
    def hasContent_(self):
        if (
            self.Default is not None or
            self.Convert is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DocTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('Default=%s,\n' % quote_python(self.Default).encode(ExternalEncoding))
        if self.Convert is not None:
            showIndent(outfile, level)
            outfile.write('Convert=%s,\n' % quote_python(self.Convert).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Default':
            Default_ = child_.text
            Default_ = self.gds_validate_string(Default_, node, 'Default')
            self.Default = Default_
        elif nodeName_ == 'Convert':
            Convert_ = child_.text
            Convert_ = self.gds_validate_string(Convert_, node, 'Convert')
            self.Convert = Convert_
# end class DocTypeType


class Default(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Default.subclass:
            return Default.subclass(*args_, **kwargs_)
        else:
            return Default(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Default', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Default')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Default'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Default', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Default'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Default


class Convert(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Convert.subclass:
            return Convert.subclass(*args_, **kwargs_)
        else:
            return Convert(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Convert', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Convert')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Convert'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Convert', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Convert'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Convert


class XSLTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, XSLTFile=None, Param=None, URLType=None, URLTransfer=None):
        self.XSLTFile = XSLTFile
        if Param is None:
            self.Param = []
        else:
            self.Param = Param
        self.URLType = URLType
        self.URLTransfer = URLTransfer
    def factory(*args_, **kwargs_):
        if XSLTType.subclass:
            return XSLTType.subclass(*args_, **kwargs_)
        else:
            return XSLTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XSLTFile(self): return self.XSLTFile
    def set_XSLTFile(self, XSLTFile): self.XSLTFile = XSLTFile
    def get_Param(self): return self.Param
    def set_Param(self, Param): self.Param = Param
    def add_Param(self, value): self.Param.append(value)
    def insert_Param(self, index, value): self.Param[index] = value
    def get_URLType(self): return self.URLType
    def set_URLType(self, URLType): self.URLType = URLType
    def get_URLTransfer(self): return self.URLTransfer
    def set_URLTransfer(self, URLTransfer): self.URLTransfer = URLTransfer
    def export(self, outfile, level, namespace_='', name_='XSLTType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XSLTType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XSLTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XSLTType', fromsubclass_=False):
        if self.XSLTFile is not None:
            showIndent(outfile, level)
            outfile.write('<%sXSLTFile>%s</%sXSLTFile>\n' % (namespace_, self.gds_format_string(quote_xml(self.XSLTFile).encode(ExternalEncoding), input_name='XSLTFile'), namespace_))
        for Param_ in self.Param:
            showIndent(outfile, level)
            outfile.write('<%sParam>%s</%sParam>\n' % (namespace_, self.gds_format_string(quote_xml(Param_).encode(ExternalEncoding), input_name='Param'), namespace_))
        if self.URLType is not None:
            self.URLType.export(outfile, level, namespace_, name_='URLType', )
        if self.URLTransfer is not None:
            showIndent(outfile, level)
            outfile.write('<%sURLTransfer>%s</%sURLTransfer>\n' % (namespace_, self.gds_format_string(quote_xml(self.URLTransfer).encode(ExternalEncoding), input_name='URLTransfer'), namespace_))
    def hasContent_(self):
        if (
            self.XSLTFile is not None or
            self.Param or
            self.URLType is not None or
            self.URLTransfer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XSLTType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.XSLTFile is not None:
            showIndent(outfile, level)
            outfile.write('XSLTFile=%s,\n' % quote_python(self.XSLTFile).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Param=[\n')
        level += 1
        for Param_ in self.Param:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Param_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.URLType is not None:
            showIndent(outfile, level)
            outfile.write('URLType=model_.string(\n')
            self.URLType.exportLiteral(outfile, level, name_='URLType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.URLTransfer is not None:
            showIndent(outfile, level)
            outfile.write('URLTransfer=%s,\n' % quote_python(self.URLTransfer).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XSLTFile':
            XSLTFile_ = child_.text
            XSLTFile_ = self.gds_validate_string(XSLTFile_, node, 'XSLTFile')
            self.XSLTFile = XSLTFile_
        elif nodeName_ == 'Param':
            Param_ = child_.text
            Param_ = self.gds_validate_string(Param_, node, 'Param')
            self.Param.append(Param_)
        elif nodeName_ == 'URLType':
            obj_ = None
            self.set_URLType(obj_)
        elif nodeName_ == 'URLTransfer':
            URLTransfer_ = child_.text
            URLTransfer_ = self.gds_validate_string(URLTransfer_, node, 'URLTransfer')
            self.URLTransfer = URLTransfer_
# end class XSLTType


class Param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Param.subclass:
            return Param.subclass(*args_, **kwargs_)
        else:
            return Param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Param', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Param')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Param'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Param', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Param'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Param


class URLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if URLType.subclass:
            return URLType.subclass(*args_, **kwargs_)
        else:
            return URLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='URLType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URLType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URLType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='URLType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class URLType


class URLTransfer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if URLTransfer.subclass:
            return URLTransfer.subclass(*args_, **kwargs_)
        else:
            return URLTransfer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='URLTransfer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URLTransfer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLTransfer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URLTransfer', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='URLTransfer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class URLTransfer


class PagingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PageTransfer=None, PageNumberName=None):
        self.PageTransfer = PageTransfer
        self.PageNumberName = PageNumberName
    def factory(*args_, **kwargs_):
        if PagingType.subclass:
            return PagingType.subclass(*args_, **kwargs_)
        else:
            return PagingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PageTransfer(self): return self.PageTransfer
    def set_PageTransfer(self, PageTransfer): self.PageTransfer = PageTransfer
    def get_PageNumberName(self): return self.PageNumberName
    def set_PageNumberName(self, PageNumberName): self.PageNumberName = PageNumberName
    def export(self, outfile, level, namespace_='', name_='PagingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PagingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PagingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PagingType', fromsubclass_=False):
        if self.PageTransfer is not None:
            showIndent(outfile, level)
            outfile.write('<%sPageTransfer>%s</%sPageTransfer>\n' % (namespace_, self.gds_format_string(quote_xml(self.PageTransfer).encode(ExternalEncoding), input_name='PageTransfer'), namespace_))
        if self.PageNumberName is not None:
            showIndent(outfile, level)
            outfile.write('<%sPageNumberName>%s</%sPageNumberName>\n' % (namespace_, self.gds_format_string(quote_xml(self.PageNumberName).encode(ExternalEncoding), input_name='PageNumberName'), namespace_))
    def hasContent_(self):
        if (
            self.PageTransfer is not None or
            self.PageNumberName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PagingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PageTransfer is not None:
            showIndent(outfile, level)
            outfile.write('PageTransfer=%s,\n' % quote_python(self.PageTransfer).encode(ExternalEncoding))
        if self.PageNumberName is not None:
            showIndent(outfile, level)
            outfile.write('PageNumberName=%s,\n' % quote_python(self.PageNumberName).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PageTransfer':
            PageTransfer_ = child_.text
            PageTransfer_ = self.gds_validate_string(PageTransfer_, node, 'PageTransfer')
            self.PageTransfer = PageTransfer_
        elif nodeName_ == 'PageNumberName':
            PageNumberName_ = child_.text
            PageNumberName_ = self.gds_validate_string(PageNumberName_, node, 'PageNumberName')
            self.PageNumberName = PageNumberName_
# end class PagingType


class PageTransfer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if PageTransfer.subclass:
            return PageTransfer.subclass(*args_, **kwargs_)
        else:
            return PageTransfer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PageTransfer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageTransfer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageTransfer'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PageTransfer', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PageTransfer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PageTransfer


class PageNumberName(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if PageNumberName.subclass:
            return PageNumberName.subclass(*args_, **kwargs_)
        else:
            return PageNumberName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PageNumberName', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PageNumberName')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PageNumberName'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PageNumberName', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PageNumberName'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PageNumberName


class DatabaseSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DatabaseType=None, ConnectionString=None, DatabaseName=None, TableName=None, Sql=None, Macro=None, MonitorColumn=None, Delimiter=None):
        self.DatabaseType = DatabaseType
        self.ConnectionString = ConnectionString
        self.DatabaseName = DatabaseName
        self.TableName = TableName
        self.Sql = Sql
        self.Macro = Macro
        self.MonitorColumn = MonitorColumn
        self.Delimiter = Delimiter
    def factory(*args_, **kwargs_):
        if DatabaseSettingType.subclass:
            return DatabaseSettingType.subclass(*args_, **kwargs_)
        else:
            return DatabaseSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DatabaseType(self): return self.DatabaseType
    def set_DatabaseType(self, DatabaseType): self.DatabaseType = DatabaseType
    def get_ConnectionString(self): return self.ConnectionString
    def set_ConnectionString(self, ConnectionString): self.ConnectionString = ConnectionString
    def get_DatabaseName(self): return self.DatabaseName
    def set_DatabaseName(self, DatabaseName): self.DatabaseName = DatabaseName
    def get_TableName(self): return self.TableName
    def set_TableName(self, TableName): self.TableName = TableName
    def get_Sql(self): return self.Sql
    def set_Sql(self, Sql): self.Sql = Sql
    def get_Macro(self): return self.Macro
    def set_Macro(self, Macro): self.Macro = Macro
    def get_MonitorColumn(self): return self.MonitorColumn
    def set_MonitorColumn(self, MonitorColumn): self.MonitorColumn = MonitorColumn
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def export(self, outfile, level, namespace_='', name_='DatabaseSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatabaseSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DatabaseSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DatabaseSettingType', fromsubclass_=False):
        if self.DatabaseType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDatabaseType>%s</%sDatabaseType>\n' % (namespace_, self.gds_format_string(quote_xml(self.DatabaseType).encode(ExternalEncoding), input_name='DatabaseType'), namespace_))
        if self.ConnectionString is not None:
            showIndent(outfile, level)
            outfile.write('<%sConnectionString>%s</%sConnectionString>\n' % (namespace_, self.gds_format_string(quote_xml(self.ConnectionString).encode(ExternalEncoding), input_name='ConnectionString'), namespace_))
        if self.DatabaseName is not None:
            showIndent(outfile, level)
            outfile.write('<%sDatabaseName>%s</%sDatabaseName>\n' % (namespace_, self.gds_format_string(quote_xml(self.DatabaseName).encode(ExternalEncoding), input_name='DatabaseName'), namespace_))
        if self.TableName is not None:
            showIndent(outfile, level)
            outfile.write('<%sTableName>%s</%sTableName>\n' % (namespace_, self.gds_format_string(quote_xml(self.TableName).encode(ExternalEncoding), input_name='TableName'), namespace_))
        if self.Sql is not None:
            showIndent(outfile, level)
            outfile.write('<%sSql>%s</%sSql>\n' % (namespace_, self.gds_format_string(quote_xml(self.Sql).encode(ExternalEncoding), input_name='Sql'), namespace_))
        if self.Macro is not None:
            showIndent(outfile, level)
            outfile.write('<%sMacro>%s</%sMacro>\n' % (namespace_, self.gds_format_string(quote_xml(self.Macro).encode(ExternalEncoding), input_name='Macro'), namespace_))
        if self.MonitorColumn is not None:
            showIndent(outfile, level)
            outfile.write('<%sMonitorColumn>%s</%sMonitorColumn>\n' % (namespace_, self.gds_format_string(quote_xml(self.MonitorColumn).encode(ExternalEncoding), input_name='MonitorColumn'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
    def hasContent_(self):
        if (
            self.DatabaseType is not None or
            self.ConnectionString is not None or
            self.DatabaseName is not None or
            self.TableName is not None or
            self.Sql is not None or
            self.Macro is not None or
            self.MonitorColumn is not None or
            self.Delimiter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DatabaseSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DatabaseType is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseType=%s,\n' % quote_python(self.DatabaseType).encode(ExternalEncoding))
        if self.ConnectionString is not None:
            showIndent(outfile, level)
            outfile.write('ConnectionString=%s,\n' % quote_python(self.ConnectionString).encode(ExternalEncoding))
        if self.DatabaseName is not None:
            showIndent(outfile, level)
            outfile.write('DatabaseName=%s,\n' % quote_python(self.DatabaseName).encode(ExternalEncoding))
        if self.TableName is not None:
            showIndent(outfile, level)
            outfile.write('TableName=%s,\n' % quote_python(self.TableName).encode(ExternalEncoding))
        if self.Sql is not None:
            showIndent(outfile, level)
            outfile.write('Sql=%s,\n' % quote_python(self.Sql).encode(ExternalEncoding))
        if self.Macro is not None:
            showIndent(outfile, level)
            outfile.write('Macro=%s,\n' % quote_python(self.Macro).encode(ExternalEncoding))
        if self.MonitorColumn is not None:
            showIndent(outfile, level)
            outfile.write('MonitorColumn=%s,\n' % quote_python(self.MonitorColumn).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DatabaseType':
            DatabaseType_ = child_.text
            DatabaseType_ = self.gds_validate_string(DatabaseType_, node, 'DatabaseType')
            self.DatabaseType = DatabaseType_
        elif nodeName_ == 'ConnectionString':
            ConnectionString_ = child_.text
            ConnectionString_ = self.gds_validate_string(ConnectionString_, node, 'ConnectionString')
            self.ConnectionString = ConnectionString_
        elif nodeName_ == 'DatabaseName':
            DatabaseName_ = child_.text
            DatabaseName_ = self.gds_validate_string(DatabaseName_, node, 'DatabaseName')
            self.DatabaseName = DatabaseName_
        elif nodeName_ == 'TableName':
            TableName_ = child_.text
            TableName_ = self.gds_validate_string(TableName_, node, 'TableName')
            self.TableName = TableName_
        elif nodeName_ == 'Sql':
            Sql_ = child_.text
            Sql_ = self.gds_validate_string(Sql_, node, 'Sql')
            self.Sql = Sql_
        elif nodeName_ == 'Macro':
            Macro_ = child_.text
            Macro_ = self.gds_validate_string(Macro_, node, 'Macro')
            self.Macro = Macro_
        elif nodeName_ == 'MonitorColumn':
            MonitorColumn_ = child_.text
            MonitorColumn_ = self.gds_validate_string(MonitorColumn_, node, 'MonitorColumn')
            self.MonitorColumn = MonitorColumn_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
# end class DatabaseSettingType


class LocalSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Path=None, FilenamePattern=None):
        self.Path = Path
        self.FilenamePattern = FilenamePattern
    def factory(*args_, **kwargs_):
        if LocalSettingType.subclass:
            return LocalSettingType.subclass(*args_, **kwargs_)
        else:
            return LocalSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Path(self): return self.Path
    def set_Path(self, Path): self.Path = Path
    def get_FilenamePattern(self): return self.FilenamePattern
    def set_FilenamePattern(self, FilenamePattern): self.FilenamePattern = FilenamePattern
    def export(self, outfile, level, namespace_='', name_='LocalSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalSettingType', fromsubclass_=False):
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('<%sPath>%s</%sPath>\n' % (namespace_, self.gds_format_string(quote_xml(self.Path).encode(ExternalEncoding), input_name='Path'), namespace_))
        if self.FilenamePattern is not None:
            showIndent(outfile, level)
            outfile.write('<%sFilenamePattern>%s</%sFilenamePattern>\n' % (namespace_, self.gds_format_string(quote_xml(self.FilenamePattern).encode(ExternalEncoding), input_name='FilenamePattern'), namespace_))
    def hasContent_(self):
        if (
            self.Path is not None or
            self.FilenamePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocalSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Path is not None:
            showIndent(outfile, level)
            outfile.write('Path=%s,\n' % quote_python(self.Path).encode(ExternalEncoding))
        if self.FilenamePattern is not None:
            showIndent(outfile, level)
            outfile.write('FilenamePattern=%s,\n' % quote_python(self.FilenamePattern).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Path':
            Path_ = child_.text
            Path_ = self.gds_validate_string(Path_, node, 'Path')
            self.Path = Path_
        elif nodeName_ == 'FilenamePattern':
            FilenamePattern_ = child_.text
            FilenamePattern_ = self.gds_validate_string(FilenamePattern_, node, 'FilenamePattern')
            self.FilenamePattern = FilenamePattern_
# end class LocalSettingType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DownloadingConfig'
        rootClass = DownloadingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DownloadingConfig'
        rootClass = DownloadingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="DownloadingConfig",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DownloadingConfig'
        rootClass = DownloadingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from downloadingconfig2 import *\n\n')
    sys.stdout.write('import downloadingconfig2 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Convert",
    "DatabaseSettingType",
    "DatePoint",
    "DateType",
    "DeclearTimeFormat",
    "Default",
    "DefaultValue",
    "Delimiter",
    "DestinationTypes",
    "DocTypeType",
    "DownloadingConfig",
    "Encoding",
    "FilterType",
    "LocalSettingType",
    "MappingIDType",
    "MarketCode",
    "OperationType",
    "PageNumberName",
    "PageTransfer",
    "PagingType",
    "Param",
    "ParseSolution",
    "Pattern",
    "PeriodType",
    "SourceType",
    "StepType",
    "Structe",
    "Title",
    "Type",
    "URLTransfer",
    "URLType",
    "Value",
    "ValueType",
    "WebSettingType",
    "XSLTType",
    "Xpath"
    ]
