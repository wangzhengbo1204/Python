#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Mon Nov 07 20:31:39 2011 by generateDS.py version 2.7a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class ParsingConfig(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MinPassedRatio=None, Encoding=None, IsCreateCleanFile=None, Pretreatment=None, ExcelSetting=None, TxtSetting=None, XmlSetting=None):
        self.MinPassedRatio = MinPassedRatio
        self.Encoding = Encoding
        self.IsCreateCleanFile = IsCreateCleanFile
        self.Pretreatment = Pretreatment
        self.ExcelSetting = ExcelSetting
        self.TxtSetting = TxtSetting
        self.XmlSetting = XmlSetting
    def factory(*args_, **kwargs_):
        if ParsingConfig.subclass:
            return ParsingConfig.subclass(*args_, **kwargs_)
        else:
            return ParsingConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MinPassedRatio(self): return self.MinPassedRatio
    def set_MinPassedRatio(self, MinPassedRatio): self.MinPassedRatio = MinPassedRatio
    def get_Encoding(self): return self.Encoding
    def set_Encoding(self, Encoding): self.Encoding = Encoding
    def get_IsCreateCleanFile(self): return self.IsCreateCleanFile
    def set_IsCreateCleanFile(self, IsCreateCleanFile): self.IsCreateCleanFile = IsCreateCleanFile
    def get_Pretreatment(self): return self.Pretreatment
    def set_Pretreatment(self, Pretreatment): self.Pretreatment = Pretreatment
    def get_ExcelSetting(self): return self.ExcelSetting
    def set_ExcelSetting(self, ExcelSetting): self.ExcelSetting = ExcelSetting
    def get_TxtSetting(self): return self.TxtSetting
    def set_TxtSetting(self, TxtSetting): self.TxtSetting = TxtSetting
    def get_XmlSetting(self): return self.XmlSetting
    def set_XmlSetting(self, XmlSetting): self.XmlSetting = XmlSetting
    def export(self, outfile, level, namespace_='', name_='ParsingConfig', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParsingConfig')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParsingConfig'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParsingConfig', fromsubclass_=False):
        if self.MinPassedRatio is not None:
            showIndent(outfile, level)
            outfile.write('<%sMinPassedRatio>%s</%sMinPassedRatio>\n' % (namespace_, self.gds_format_float(self.MinPassedRatio, input_name='MinPassedRatio'), namespace_))
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('<%sEncoding>%s</%sEncoding>\n' % (namespace_, self.gds_format_string(quote_xml(self.Encoding).encode(ExternalEncoding), input_name='Encoding'), namespace_))
        if self.IsCreateCleanFile is not None:
            showIndent(outfile, level)
            outfile.write('<%sIsCreateCleanFile>%s</%sIsCreateCleanFile>\n' % (namespace_, self.gds_format_boolean(self.gds_str_lower(str(self.IsCreateCleanFile)), input_name='IsCreateCleanFile'), namespace_))
        if self.Pretreatment is not None:
            self.Pretreatment.export(outfile, level, namespace_, name_='Pretreatment')
        if self.ExcelSetting is not None:
            self.ExcelSetting.export(outfile, level, namespace_, name_='ExcelSetting')
        if self.TxtSetting is not None:
            self.TxtSetting.export(outfile, level, namespace_, name_='TxtSetting')
        if self.XmlSetting is not None:
            self.XmlSetting.export(outfile, level, namespace_, name_='XmlSetting', )
    def hasContent_(self):
        if (
            self.MinPassedRatio is not None or
            self.Encoding is not None or
            self.IsCreateCleanFile is not None or
            self.Pretreatment is not None or
            self.ExcelSetting is not None or
            self.TxtSetting is not None or
            self.XmlSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParsingConfig'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MinPassedRatio is not None:
            showIndent(outfile, level)
            outfile.write('MinPassedRatio=%f,\n' % self.MinPassedRatio)
        if self.Encoding is not None:
            showIndent(outfile, level)
            outfile.write('Encoding=%s,\n' % quote_python(self.Encoding).encode(ExternalEncoding))
        if self.IsCreateCleanFile is not None:
            showIndent(outfile, level)
            outfile.write('IsCreateCleanFile=%s,\n' % self.IsCreateCleanFile)
        if self.Pretreatment is not None:
            showIndent(outfile, level)
            outfile.write('Pretreatment=model_.PretreatmentType(\n')
            self.Pretreatment.exportLiteral(outfile, level, name_='Pretreatment')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExcelSetting is not None:
            showIndent(outfile, level)
            outfile.write('ExcelSetting=model_.ExcelSettingType(\n')
            self.ExcelSetting.exportLiteral(outfile, level, name_='ExcelSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TxtSetting is not None:
            showIndent(outfile, level)
            outfile.write('TxtSetting=model_.TxtSettingType(\n')
            self.TxtSetting.exportLiteral(outfile, level, name_='TxtSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.XmlSetting is not None:
            showIndent(outfile, level)
            outfile.write('XmlSetting=model_.XmlSettingType(\n')
            self.XmlSetting.exportLiteral(outfile, level, name_='XmlSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MinPassedRatio':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'MinPassedRatio')
            self.MinPassedRatio = fval_
        elif nodeName_ == 'Encoding':
            Encoding_ = child_.text
            Encoding_ = self.gds_validate_string(Encoding_, node, 'Encoding')
            self.Encoding = Encoding_
        elif nodeName_ == 'IsCreateCleanFile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsCreateCleanFile')
            self.IsCreateCleanFile = ival_
        elif nodeName_ == 'Pretreatment':
            obj_ = PretreatmentType.factory()
            obj_.build(child_)
            self.set_Pretreatment(obj_)
        elif nodeName_ == 'ExcelSetting':
            obj_ = ExcelSettingType.factory()
            obj_.build(child_)
            self.set_ExcelSetting(obj_)
        elif nodeName_ == 'TxtSetting':
            obj_ = TxtSettingType.factory()
            obj_.build(child_)
            self.set_TxtSetting(obj_)
        elif nodeName_ == 'XmlSetting':
            obj_ = XmlSettingType.factory()
            obj_.build(child_)
            self.set_XmlSetting(obj_)
# end class ParsingConfig


class PretreatmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Delimiter=None, PreSpecial=None, PreExcelSetting=None):
        self.Delimiter = Delimiter
        self.PreSpecial = PreSpecial
        self.PreExcelSetting = PreExcelSetting
    def factory(*args_, **kwargs_):
        if PretreatmentType.subclass:
            return PretreatmentType.subclass(*args_, **kwargs_)
        else:
            return PretreatmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_PreSpecial(self): return self.PreSpecial
    def set_PreSpecial(self, PreSpecial): self.PreSpecial = PreSpecial
    def get_PreExcelSetting(self): return self.PreExcelSetting
    def set_PreExcelSetting(self, PreExcelSetting): self.PreExcelSetting = PreExcelSetting
    def export(self, outfile, level, namespace_='', name_='PretreatmentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PretreatmentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PretreatmentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PretreatmentType', fromsubclass_=False):
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
        if self.PreSpecial is not None:
            self.PreSpecial.export(outfile, level, namespace_, name_='PreSpecial', )
        if self.PreExcelSetting is not None:
            self.PreExcelSetting.export(outfile, level, namespace_, name_='PreExcelSetting')
    def hasContent_(self):
        if (
            self.Delimiter is not None or
            self.PreSpecial is not None or
            self.PreExcelSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PretreatmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
        if self.PreSpecial is not None:
            showIndent(outfile, level)
            outfile.write('PreSpecial=model_.PreSpecialType(\n')
            self.PreSpecial.exportLiteral(outfile, level, name_='PreSpecial')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PreExcelSetting is not None:
            showIndent(outfile, level)
            outfile.write('PreExcelSetting=model_.PreExcelSettingType(\n')
            self.PreExcelSetting.exportLiteral(outfile, level, name_='PreExcelSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
        elif nodeName_ == 'PreSpecial':
            obj_ = PreSpecialType.factory()
            obj_.build(child_)
            self.set_PreSpecial(obj_)
        elif nodeName_ == 'PreExcelSetting':
            obj_ = PreExcelSettingType.factory()
            obj_.build(child_)
            self.set_PreExcelSetting(obj_)
# end class PretreatmentType


class Delimiter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Delimiter.subclass:
            return Delimiter.subclass(*args_, **kwargs_)
        else:
            return Delimiter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Delimiter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Delimiter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Delimiter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Delimiter', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Delimiter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Delimiter


class PreSpecialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Function=None):
        self.Function = Function
    def factory(*args_, **kwargs_):
        if PreSpecialType.subclass:
            return PreSpecialType.subclass(*args_, **kwargs_)
        else:
            return PreSpecialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Function(self): return self.Function
    def set_Function(self, Function): self.Function = Function
    def export(self, outfile, level, namespace_='', name_='PreSpecialType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PreSpecialType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PreSpecialType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PreSpecialType', fromsubclass_=False):
        if self.Function is not None:
            showIndent(outfile, level)
            outfile.write('<%sFunction>%s</%sFunction>\n' % (namespace_, self.gds_format_string(quote_xml(self.Function).encode(ExternalEncoding), input_name='Function'), namespace_))
    def hasContent_(self):
        if (
            self.Function is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PreSpecialType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Function is not None:
            showIndent(outfile, level)
            outfile.write('Function=%s,\n' % quote_python(self.Function).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Function':
            Function_ = child_.text
            Function_ = self.gds_validate_string(Function_, node, 'Function')
            self.Function = Function_
# end class PreSpecialType


class Function(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Function.subclass:
            return Function.subclass(*args_, **kwargs_)
        else:
            return Function(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Function', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Function')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Function'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Function', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Function'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Function


class PreExcelSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Orientation=None, PreSheet=None):
        self.Orientation = Orientation
        if PreSheet is None:
            self.PreSheet = []
        else:
            self.PreSheet = PreSheet
    def factory(*args_, **kwargs_):
        if PreExcelSettingType.subclass:
            return PreExcelSettingType.subclass(*args_, **kwargs_)
        else:
            return PreExcelSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_PreSheet(self): return self.PreSheet
    def set_PreSheet(self, PreSheet): self.PreSheet = PreSheet
    def add_PreSheet(self, value): self.PreSheet.append(value)
    def insert_PreSheet(self, index, value): self.PreSheet[index] = value
    def export(self, outfile, level, namespace_='', name_='PreExcelSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PreExcelSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PreExcelSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PreExcelSettingType', fromsubclass_=False):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrientation>%s</%sOrientation>\n' % (namespace_, self.gds_format_integer(self.Orientation, input_name='Orientation'), namespace_))
        for PreSheet_ in self.PreSheet:
            PreSheet_.export(outfile, level, namespace_, name_='PreSheet')
    def hasContent_(self):
        if (
            self.Orientation is not None or
            self.PreSheet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PreExcelSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('Orientation=%d,\n' % self.Orientation)
        showIndent(outfile, level)
        outfile.write('PreSheet=[\n')
        level += 1
        for PreSheet_ in self.PreSheet:
            showIndent(outfile, level)
            outfile.write('model_.PreSheetType(\n')
            PreSheet_.exportLiteral(outfile, level, name_='PreSheetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Orientation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Orientation')
            self.Orientation = ival_
        elif nodeName_ == 'PreSheet':
            obj_ = PreSheetType.factory()
            obj_.build(child_)
            self.PreSheet.append(obj_)
# end class PreExcelSettingType


class PreSheetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, PreRegion=None, IdtSetting=None):
        self.Index = Index
        self.PreRegion = PreRegion
        if IdtSetting is None:
            self.IdtSetting = []
        else:
            self.IdtSetting = IdtSetting
    def factory(*args_, **kwargs_):
        if PreSheetType.subclass:
            return PreSheetType.subclass(*args_, **kwargs_)
        else:
            return PreSheetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_PreRegion(self): return self.PreRegion
    def set_PreRegion(self, PreRegion): self.PreRegion = PreRegion
    def get_IdtSetting(self): return self.IdtSetting
    def set_IdtSetting(self, IdtSetting): self.IdtSetting = IdtSetting
    def add_IdtSetting(self, value): self.IdtSetting.append(value)
    def insert_IdtSetting(self, index, value): self.IdtSetting[index] = value
    def export(self, outfile, level, namespace_='', name_='PreSheetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PreSheetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PreSheetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PreSheetType', fromsubclass_=False):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('<%sIndex>%s</%sIndex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Index).encode(ExternalEncoding), input_name='Index'), namespace_))
        if self.PreRegion is not None:
            self.PreRegion.export(outfile, level, namespace_, name_='PreRegion', )
        for IdtSetting_ in self.IdtSetting:
            IdtSetting_.export(outfile, level, namespace_, name_='IdtSetting')
    def hasContent_(self):
        if (
            self.Index is not None or
            self.PreRegion is not None or
            self.IdtSetting
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PreSheetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%s,\n' % quote_python(self.Index).encode(ExternalEncoding))
        if self.PreRegion is not None:
            showIndent(outfile, level)
            outfile.write('PreRegion=model_.PreRegionType(\n')
            self.PreRegion.exportLiteral(outfile, level, name_='PreRegion')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('IdtSetting=[\n')
        level += 1
        for IdtSetting_ in self.IdtSetting:
            showIndent(outfile, level)
            outfile.write('model_.IdtSettingType(\n')
            IdtSetting_.exportLiteral(outfile, level, name_='IdtSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            Index_ = child_.text
            Index_ = self.gds_validate_string(Index_, node, 'Index')
            self.Index = Index_
        elif nodeName_ == 'PreRegion':
            obj_ = PreRegionType.factory()
            obj_.build(child_)
            self.set_PreRegion(obj_)
        elif nodeName_ == 'IdtSetting':
            obj_ = IdtSettingType.factory()
            obj_.build(child_)
            self.IdtSetting.append(obj_)
# end class PreSheetType


class Index(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Index.subclass:
            return Index.subclass(*args_, **kwargs_)
        else:
            return Index(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Index', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Index')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Index'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Index', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Index'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Index


class PreRegionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartLine=None, EndLine=None, Step=None):
        self.StartLine = StartLine
        self.EndLine = EndLine
        self.Step = Step
    def factory(*args_, **kwargs_):
        if PreRegionType.subclass:
            return PreRegionType.subclass(*args_, **kwargs_)
        else:
            return PreRegionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartLine(self): return self.StartLine
    def set_StartLine(self, StartLine): self.StartLine = StartLine
    def get_EndLine(self): return self.EndLine
    def set_EndLine(self, EndLine): self.EndLine = EndLine
    def get_Step(self): return self.Step
    def set_Step(self, Step): self.Step = Step
    def export(self, outfile, level, namespace_='', name_='PreRegionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PreRegionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PreRegionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PreRegionType', fromsubclass_=False):
        if self.StartLine is not None:
            self.StartLine.export(outfile, level, namespace_, name_='StartLine', )
        if self.EndLine is not None:
            self.EndLine.export(outfile, level, namespace_, name_='EndLine', )
        if self.Step is not None:
            showIndent(outfile, level)
            outfile.write('<%sStep>%s</%sStep>\n' % (namespace_, self.gds_format_string(quote_xml(self.Step).encode(ExternalEncoding), input_name='Step'), namespace_))
    def hasContent_(self):
        if (
            self.StartLine is not None or
            self.EndLine is not None or
            self.Step is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PreRegionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartLine is not None:
            showIndent(outfile, level)
            outfile.write('StartLine=model_.StartLineType(\n')
            self.StartLine.exportLiteral(outfile, level, name_='StartLine')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndLine is not None:
            showIndent(outfile, level)
            outfile.write('EndLine=model_.EndLineType(\n')
            self.EndLine.exportLiteral(outfile, level, name_='EndLine')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Step is not None:
            showIndent(outfile, level)
            outfile.write('Step=%s,\n' % quote_python(self.Step).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartLine':
            obj_ = StartLineType.factory()
            obj_.build(child_)
            self.set_StartLine(obj_)
        elif nodeName_ == 'EndLine':
            obj_ = EndLineType.factory()
            obj_.build(child_)
            self.set_EndLine(obj_)
        elif nodeName_ == 'Step':
            Step_ = child_.text
            Step_ = self.gds_validate_string(Step_, node, 'Step')
            self.Step = Step_
# end class PreRegionType


class Step(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Step', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Step')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Step'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Step', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Step'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Step


class StartLineType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowIndex=None, ColIndex=None):
        self.RowIndex = RowIndex
        self.ColIndex = ColIndex
    def factory(*args_, **kwargs_):
        if StartLineType.subclass:
            return StartLineType.subclass(*args_, **kwargs_)
        else:
            return StartLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowIndex(self): return self.RowIndex
    def set_RowIndex(self, RowIndex): self.RowIndex = RowIndex
    def get_ColIndex(self): return self.ColIndex
    def set_ColIndex(self, ColIndex): self.ColIndex = ColIndex
    def export(self, outfile, level, namespace_='', name_='StartLineType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartLineType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StartLineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StartLineType', fromsubclass_=False):
        if self.RowIndex is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowIndex>%s</%sRowIndex>\n' % (namespace_, self.gds_format_string(quote_xml(self.RowIndex).encode(ExternalEncoding), input_name='RowIndex'), namespace_))
        if self.ColIndex is not None:
            showIndent(outfile, level)
            outfile.write('<%sColIndex>%s</%sColIndex>\n' % (namespace_, self.gds_format_string(quote_xml(self.ColIndex).encode(ExternalEncoding), input_name='ColIndex'), namespace_))
    def hasContent_(self):
        if (
            self.RowIndex is not None or
            self.ColIndex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StartLineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowIndex is not None:
            showIndent(outfile, level)
            outfile.write('RowIndex=%s,\n' % quote_python(self.RowIndex).encode(ExternalEncoding))
        if self.ColIndex is not None:
            showIndent(outfile, level)
            outfile.write('ColIndex=%s,\n' % quote_python(self.ColIndex).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowIndex':
            RowIndex_ = child_.text
            RowIndex_ = self.gds_validate_string(RowIndex_, node, 'RowIndex')
            self.RowIndex = RowIndex_
        elif nodeName_ == 'ColIndex':
            ColIndex_ = child_.text
            ColIndex_ = self.gds_validate_string(ColIndex_, node, 'ColIndex')
            self.ColIndex = ColIndex_
# end class StartLineType


class RowIndex(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if RowIndex.subclass:
            return RowIndex.subclass(*args_, **kwargs_)
        else:
            return RowIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='RowIndex', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RowIndex')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RowIndex'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RowIndex', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RowIndex'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RowIndex


class ColIndex(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ColIndex.subclass:
            return ColIndex.subclass(*args_, **kwargs_)
        else:
            return ColIndex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ColIndex', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ColIndex')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ColIndex'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ColIndex', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ColIndex'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ColIndex


class EndLineType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MaxBlankNumber=None, EndLineRegex=None):
        self.MaxBlankNumber = MaxBlankNumber
        self.EndLineRegex = EndLineRegex
    def factory(*args_, **kwargs_):
        if EndLineType.subclass:
            return EndLineType.subclass(*args_, **kwargs_)
        else:
            return EndLineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaxBlankNumber(self): return self.MaxBlankNumber
    def set_MaxBlankNumber(self, MaxBlankNumber): self.MaxBlankNumber = MaxBlankNumber
    def get_EndLineRegex(self): return self.EndLineRegex
    def set_EndLineRegex(self, EndLineRegex): self.EndLineRegex = EndLineRegex
    def export(self, outfile, level, namespace_='', name_='EndLineType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineType', fromsubclass_=False):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxBlankNumber>%s</%sMaxBlankNumber>\n' % (namespace_, self.gds_format_integer(self.MaxBlankNumber, input_name='MaxBlankNumber'), namespace_))
        if self.EndLineRegex is not None:
            self.EndLineRegex.export(outfile, level, namespace_, name_='EndLineRegex')
    def hasContent_(self):
        if (
            self.MaxBlankNumber is not None or
            self.EndLineRegex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('MaxBlankNumber=%d,\n' % self.MaxBlankNumber)
        if self.EndLineRegex is not None:
            showIndent(outfile, level)
            outfile.write('EndLineRegex=model_.EndLineRegexType(\n')
            self.EndLineRegex.exportLiteral(outfile, level, name_='EndLineRegex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaxBlankNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxBlankNumber')
            self.MaxBlankNumber = ival_
        elif nodeName_ == 'EndLineRegex':
            obj_ = EndLineRegexType.factory()
            obj_.build(child_)
            self.set_EndLineRegex(obj_)
# end class EndLineType


class EndLineRegexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, RegexExp=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.RegexExp = RegexExp
    def factory(*args_, **kwargs_):
        if EndLineRegexType.subclass:
            return EndLineRegexType.subclass(*args_, **kwargs_)
        else:
            return EndLineRegexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_RegexExp(self): return self.RegexExp
    def set_RegexExp(self, RegexExp): self.RegexExp = RegexExp
    def export(self, outfile, level, namespace_='', name_='EndLineRegexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineRegexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineRegexType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineRegexType', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('<%sRegexExp>%s</%sRegexExp>\n' % (namespace_, self.gds_format_string(quote_xml(self.RegexExp).encode(ExternalEncoding), input_name='RegexExp'), namespace_))
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.RegexExp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineRegexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('RegexExp=%s,\n' % quote_python(self.RegexExp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'RegexExp':
            RegexExp_ = child_.text
            RegexExp_ = self.gds_validate_string(RegexExp_, node, 'RegexExp')
            self.RegexExp = RegexExp_
# end class EndLineRegexType


class AbsoluteExpression(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if AbsoluteExpression.subclass:
            return AbsoluteExpression.subclass(*args_, **kwargs_)
        else:
            return AbsoluteExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AbsoluteExpression', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsoluteExpression')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbsoluteExpression'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AbsoluteExpression', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AbsoluteExpression'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbsoluteExpression


class RegexExp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if RegexExp.subclass:
            return RegexExp.subclass(*args_, **kwargs_)
        else:
            return RegexExp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='RegexExp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegexExp')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegexExp'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegexExp', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegexExp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RegexExp


class IdtSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ColSetting=None, RowSetting=None, PointSetting=None):
        if ColSetting is None:
            self.ColSetting = []
        else:
            self.ColSetting = ColSetting
        if RowSetting is None:
            self.RowSetting = []
        else:
            self.RowSetting = RowSetting
        self.PointSetting = PointSetting
    def factory(*args_, **kwargs_):
        if IdtSettingType.subclass:
            return IdtSettingType.subclass(*args_, **kwargs_)
        else:
            return IdtSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ColSetting(self): return self.ColSetting
    def set_ColSetting(self, ColSetting): self.ColSetting = ColSetting
    def add_ColSetting(self, value): self.ColSetting.append(value)
    def insert_ColSetting(self, index, value): self.ColSetting[index] = value
    def get_RowSetting(self): return self.RowSetting
    def set_RowSetting(self, RowSetting): self.RowSetting = RowSetting
    def add_RowSetting(self, value): self.RowSetting.append(value)
    def insert_RowSetting(self, index, value): self.RowSetting[index] = value
    def get_PointSetting(self): return self.PointSetting
    def set_PointSetting(self, PointSetting): self.PointSetting = PointSetting
    def export(self, outfile, level, namespace_='', name_='IdtSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdtSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdtSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IdtSettingType', fromsubclass_=False):
        for ColSetting_ in self.ColSetting:
            ColSetting_.export(outfile, level, namespace_, name_='ColSetting')
        for RowSetting_ in self.RowSetting:
            RowSetting_.export(outfile, level, namespace_, name_='RowSetting')
        if self.PointSetting is not None:
            self.PointSetting.export(outfile, level, namespace_, name_='PointSetting', )
    def hasContent_(self):
        if (
            self.ColSetting or
            self.RowSetting or
            self.PointSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IdtSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ColSetting=[\n')
        level += 1
        for ColSetting_ in self.ColSetting:
            showIndent(outfile, level)
            outfile.write('model_.ColSettingType(\n')
            ColSetting_.exportLiteral(outfile, level, name_='ColSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('RowSetting=[\n')
        level += 1
        for RowSetting_ in self.RowSetting:
            showIndent(outfile, level)
            outfile.write('model_.RowSettingType(\n')
            RowSetting_.exportLiteral(outfile, level, name_='RowSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PointSetting is not None:
            showIndent(outfile, level)
            outfile.write('PointSetting=model_.PointSettingType(\n')
            self.PointSetting.exportLiteral(outfile, level, name_='PointSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ColSetting':
            obj_ = ColSettingType.factory()
            obj_.build(child_)
            self.ColSetting.append(obj_)
        elif nodeName_ == 'RowSetting':
            obj_ = RowSettingType.factory()
            obj_.build(child_)
            self.RowSetting.append(obj_)
        elif nodeName_ == 'PointSetting':
            obj_ = PointSettingType.factory()
            obj_.build(child_)
            self.set_PointSetting(obj_)
# end class IdtSettingType


class ColSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CellStyle=None, LineStyle=None, PointStyle=None):
        if CellStyle is None:
            self.CellStyle = []
        else:
            self.CellStyle = CellStyle
        if LineStyle is None:
            self.LineStyle = []
        else:
            self.LineStyle = LineStyle
        if PointStyle is None:
            self.PointStyle = []
        else:
            self.PointStyle = PointStyle
    def factory(*args_, **kwargs_):
        if ColSettingType.subclass:
            return ColSettingType.subclass(*args_, **kwargs_)
        else:
            return ColSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellStyle(self): return self.CellStyle
    def set_CellStyle(self, CellStyle): self.CellStyle = CellStyle
    def add_CellStyle(self, value): self.CellStyle.append(value)
    def insert_CellStyle(self, index, value): self.CellStyle[index] = value
    def get_LineStyle(self): return self.LineStyle
    def set_LineStyle(self, LineStyle): self.LineStyle = LineStyle
    def add_LineStyle(self, value): self.LineStyle.append(value)
    def insert_LineStyle(self, index, value): self.LineStyle[index] = value
    def get_PointStyle(self): return self.PointStyle
    def set_PointStyle(self, PointStyle): self.PointStyle = PointStyle
    def add_PointStyle(self, value): self.PointStyle.append(value)
    def insert_PointStyle(self, index, value): self.PointStyle[index] = value
    def export(self, outfile, level, namespace_='', name_='ColSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ColSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ColSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ColSettingType', fromsubclass_=False):
        for CellStyle_ in self.CellStyle:
            CellStyle_.export(outfile, level, namespace_, name_='CellStyle')
        for LineStyle_ in self.LineStyle:
            LineStyle_.export(outfile, level, namespace_, name_='LineStyle')
        for PointStyle_ in self.PointStyle:
            PointStyle_.export(outfile, level, namespace_, name_='PointStyle')
    def hasContent_(self):
        if (
            self.CellStyle or
            self.LineStyle or
            self.PointStyle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ColSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CellStyle=[\n')
        level += 1
        for CellStyle_ in self.CellStyle:
            showIndent(outfile, level)
            outfile.write('model_.CellStyleType(\n')
            CellStyle_.exportLiteral(outfile, level, name_='CellStyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('LineStyle=[\n')
        level += 1
        for LineStyle_ in self.LineStyle:
            showIndent(outfile, level)
            outfile.write('model_.LineStyleType(\n')
            LineStyle_.exportLiteral(outfile, level, name_='LineStyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PointStyle=[\n')
        level += 1
        for PointStyle_ in self.PointStyle:
            showIndent(outfile, level)
            outfile.write('model_.PointStyleType(\n')
            PointStyle_.exportLiteral(outfile, level, name_='PointStyleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellStyle':
            obj_ = CellStyleType.factory()
            obj_.build(child_)
            self.CellStyle.append(obj_)
        elif nodeName_ == 'LineStyle':
            obj_ = LineStyleType.factory()
            obj_.build(child_)
            self.LineStyle.append(obj_)
        elif nodeName_ == 'PointStyle':
            obj_ = PointStyleType.factory()
            obj_.build(child_)
            self.PointStyle.append(obj_)
# end class ColSettingType


class CellStyleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        if ValuePattern is None:
            self.ValuePattern = []
        else:
            self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if CellStyleType.subclass:
            return CellStyleType.subclass(*args_, **kwargs_)
        else:
            return CellStyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def add_ValuePattern(self, value): self.ValuePattern.append(value)
    def insert_ValuePattern(self, index, value): self.ValuePattern[index] = value
    def export(self, outfile, level, namespace_='', name_='CellStyleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CellStyleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CellStyleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CellStyleType', fromsubclass_=False):
        for ValuePattern_ in self.ValuePattern:
            ValuePattern_.export(outfile, level, namespace_, name_='ValuePattern')
    def hasContent_(self):
        if (
            self.ValuePattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CellStyleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ValuePattern=[\n')
        level += 1
        for ValuePattern_ in self.ValuePattern:
            showIndent(outfile, level)
            outfile.write('model_.ValuePatternType(\n')
            ValuePattern_.exportLiteral(outfile, level, name_='ValuePatternType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType.factory()
            obj_.build(child_)
            self.ValuePattern.append(obj_)
# end class CellStyleType


class ValuePatternType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType.subclass:
            return ValuePatternType.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType


class LocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType.subclass:
            return LocationType.subclass(*args_, **kwargs_)
        else:
            return LocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType


class FixedLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType.subclass:
            return FixedLocationType.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType


class LineStyleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if LineStyleType.subclass:
            return LineStyleType.subclass(*args_, **kwargs_)
        else:
            return LineStyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def export(self, outfile, level, namespace_='', name_='LineStyleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineStyleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineStyleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LineStyleType', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineStyleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType1(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType1.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class LineStyleType


class ValuePatternType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType1.subclass:
            return ValuePatternType1.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType1', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType1(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType1.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType1


class LocationType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType1.subclass:
            return LocationType1.subclass(*args_, **kwargs_)
        else:
            return LocationType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType1', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType1(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType1.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType1


class FixedLocationType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType1.subclass:
            return FixedLocationType1.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType1', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType1


class PointStyleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if PointStyleType.subclass:
            return PointStyleType.subclass(*args_, **kwargs_)
        else:
            return PointStyleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def export(self, outfile, level, namespace_='', name_='PointStyleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointStyleType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointStyleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PointStyleType', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointStyleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType2(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType2.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class PointStyleType


class ValuePatternType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType2.subclass:
            return ValuePatternType2.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType2', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType2(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType2.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType2


class LocationType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType2.subclass:
            return LocationType2.subclass(*args_, **kwargs_)
        else:
            return LocationType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType2', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType2(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType2.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType2


class FixedLocationType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType2.subclass:
            return FixedLocationType2.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType2', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType2


class RowSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CellStyle=None, LineStyle=None, PointStyle=None):
        self.CellStyle = CellStyle
        self.LineStyle = LineStyle
        self.PointStyle = PointStyle
    def factory(*args_, **kwargs_):
        if RowSettingType.subclass:
            return RowSettingType.subclass(*args_, **kwargs_)
        else:
            return RowSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CellStyle(self): return self.CellStyle
    def set_CellStyle(self, CellStyle): self.CellStyle = CellStyle
    def get_LineStyle(self): return self.LineStyle
    def set_LineStyle(self, LineStyle): self.LineStyle = LineStyle
    def get_PointStyle(self): return self.PointStyle
    def set_PointStyle(self, PointStyle): self.PointStyle = PointStyle
    def export(self, outfile, level, namespace_='', name_='RowSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RowSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RowSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RowSettingType', fromsubclass_=False):
        if self.CellStyle is not None:
            self.CellStyle.export(outfile, level, namespace_, name_='CellStyle')
        if self.LineStyle is not None:
            self.LineStyle.export(outfile, level, namespace_, name_='LineStyle')
        if self.PointStyle is not None:
            self.PointStyle.export(outfile, level, namespace_, name_='PointStyle')
    def hasContent_(self):
        if (
            self.CellStyle is not None or
            self.LineStyle is not None or
            self.PointStyle is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RowSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CellStyle is not None:
            showIndent(outfile, level)
            outfile.write('CellStyle=model_.CellStyleType1(\n')
            self.CellStyle.exportLiteral(outfile, level, name_='CellStyle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LineStyle is not None:
            showIndent(outfile, level)
            outfile.write('LineStyle=model_.LineStyleType1(\n')
            self.LineStyle.exportLiteral(outfile, level, name_='LineStyle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PointStyle is not None:
            showIndent(outfile, level)
            outfile.write('PointStyle=model_.PointStyleType1(\n')
            self.PointStyle.exportLiteral(outfile, level, name_='PointStyle')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CellStyle':
            obj_ = CellStyleType1.factory()
            obj_.build(child_)
            self.set_CellStyle(obj_)
        elif nodeName_ == 'LineStyle':
            obj_ = LineStyleType1.factory()
            obj_.build(child_)
            self.set_LineStyle(obj_)
        elif nodeName_ == 'PointStyle':
            obj_ = PointStyleType1.factory()
            obj_.build(child_)
            self.set_PointStyle(obj_)
# end class RowSettingType


class CellStyleType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        if ValuePattern is None:
            self.ValuePattern = []
        else:
            self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if CellStyleType1.subclass:
            return CellStyleType1.subclass(*args_, **kwargs_)
        else:
            return CellStyleType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def add_ValuePattern(self, value): self.ValuePattern.append(value)
    def insert_ValuePattern(self, index, value): self.ValuePattern[index] = value
    def export(self, outfile, level, namespace_='', name_='CellStyleType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CellStyleType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CellStyleType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CellStyleType1', fromsubclass_=False):
        for ValuePattern_ in self.ValuePattern:
            ValuePattern_.export(outfile, level, namespace_, name_='ValuePattern')
    def hasContent_(self):
        if (
            self.ValuePattern
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CellStyleType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ValuePattern=[\n')
        level += 1
        for ValuePattern_ in self.ValuePattern:
            showIndent(outfile, level)
            outfile.write('model_.ValuePatternType3(\n')
            ValuePattern_.exportLiteral(outfile, level, name_='ValuePatternType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType3.factory()
            obj_.build(child_)
            self.ValuePattern.append(obj_)
# end class CellStyleType1


class ValuePatternType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType3.subclass:
            return ValuePatternType3.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType3', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType3(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType3.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType3


class LocationType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType3.subclass:
            return LocationType3.subclass(*args_, **kwargs_)
        else:
            return LocationType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType3', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType3(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType3.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType3


class FixedLocationType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType3.subclass:
            return FixedLocationType3.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType3', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType3


class LineStyleType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if LineStyleType1.subclass:
            return LineStyleType1.subclass(*args_, **kwargs_)
        else:
            return LineStyleType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def export(self, outfile, level, namespace_='', name_='LineStyleType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineStyleType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineStyleType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LineStyleType1', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineStyleType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType4(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType4.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class LineStyleType1


class ValuePatternType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType4.subclass:
            return ValuePatternType4.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType4', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType4')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType4', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType4(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType4.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType4


class LocationType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType4.subclass:
            return LocationType4.subclass(*args_, **kwargs_)
        else:
            return LocationType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType4', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType4')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType4', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType4(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType4.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType4


class FixedLocationType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType4.subclass:
            return FixedLocationType4.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType4', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType4')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType4', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType4


class PointStyleType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if PointStyleType1.subclass:
            return PointStyleType1.subclass(*args_, **kwargs_)
        else:
            return PointStyleType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def export(self, outfile, level, namespace_='', name_='PointStyleType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointStyleType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointStyleType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PointStyleType1', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointStyleType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType5(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType5.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class PointStyleType1


class ValuePatternType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType5.subclass:
            return ValuePatternType5.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType5', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType5')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType5', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType5'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType5(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType5.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType5


class LocationType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType5.subclass:
            return LocationType5.subclass(*args_, **kwargs_)
        else:
            return LocationType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType5', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType5')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType5', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType5'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType5(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType5.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType5


class FixedLocationType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType5.subclass:
            return FixedLocationType5.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType5', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType5')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType5', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType5'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType5


class PointSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ValuePattern=None):
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if PointSettingType.subclass:
            return PointSettingType.subclass(*args_, **kwargs_)
        else:
            return PointSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def export(self, outfile, level, namespace_='', name_='PointSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PointSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PointSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PointSettingType', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PointSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType6(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType6.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class PointSettingType


class ValuePatternType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType6.subclass:
            return ValuePatternType6.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType6', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType6')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType6', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType6'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType6(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType6.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType6


class LocationType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType6.subclass:
            return LocationType6.subclass(*args_, **kwargs_)
        else:
            return LocationType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType6', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType6')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType6', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType6'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType6(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType6.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType6


class FixedLocationType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType6.subclass:
            return FixedLocationType6.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType6', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType6')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType6', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType6'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType6


class ExcelSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Orientation=None, Sheet=None):
        self.Orientation = Orientation
        if Sheet is None:
            self.Sheet = []
        else:
            self.Sheet = Sheet
    def factory(*args_, **kwargs_):
        if ExcelSettingType.subclass:
            return ExcelSettingType.subclass(*args_, **kwargs_)
        else:
            return ExcelSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_Sheet(self): return self.Sheet
    def set_Sheet(self, Sheet): self.Sheet = Sheet
    def add_Sheet(self, value): self.Sheet.append(value)
    def insert_Sheet(self, index, value): self.Sheet[index] = value
    def export(self, outfile, level, namespace_='', name_='ExcelSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExcelSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExcelSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExcelSettingType', fromsubclass_=False):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrientation>%s</%sOrientation>\n' % (namespace_, self.gds_format_integer(self.Orientation, input_name='Orientation'), namespace_))
        for Sheet_ in self.Sheet:
            Sheet_.export(outfile, level, namespace_, name_='Sheet')
    def hasContent_(self):
        if (
            self.Orientation is not None or
            self.Sheet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExcelSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('Orientation=%d,\n' % self.Orientation)
        showIndent(outfile, level)
        outfile.write('Sheet=[\n')
        level += 1
        for Sheet_ in self.Sheet:
            showIndent(outfile, level)
            outfile.write('model_.SheetType(\n')
            Sheet_.exportLiteral(outfile, level, name_='SheetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Orientation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Orientation')
            self.Orientation = ival_
        elif nodeName_ == 'Sheet':
            obj_ = SheetType.factory()
            obj_.build(child_)
            self.Sheet.append(obj_)
# end class ExcelSettingType


class SheetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, Region=None, GroupSetting=None):
        self.Index = Index
        self.Region = Region
        if GroupSetting is None:
            self.GroupSetting = []
        else:
            self.GroupSetting = GroupSetting
    def factory(*args_, **kwargs_):
        if SheetType.subclass:
            return SheetType.subclass(*args_, **kwargs_)
        else:
            return SheetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Region(self): return self.Region
    def set_Region(self, Region): self.Region = Region
    def get_GroupSetting(self): return self.GroupSetting
    def set_GroupSetting(self, GroupSetting): self.GroupSetting = GroupSetting
    def add_GroupSetting(self, value): self.GroupSetting.append(value)
    def insert_GroupSetting(self, index, value): self.GroupSetting[index] = value
    def export(self, outfile, level, namespace_='', name_='SheetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SheetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SheetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SheetType', fromsubclass_=False):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('<%sIndex>%s</%sIndex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Index).encode(ExternalEncoding), input_name='Index'), namespace_))
        if self.Region is not None:
            self.Region.export(outfile, level, namespace_, name_='Region', )
        for GroupSetting_ in self.GroupSetting:
            GroupSetting_.export(outfile, level, namespace_, name_='GroupSetting')
    def hasContent_(self):
        if (
            self.Index is not None or
            self.Region is not None or
            self.GroupSetting
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SheetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%s,\n' % quote_python(self.Index).encode(ExternalEncoding))
        if self.Region is not None:
            showIndent(outfile, level)
            outfile.write('Region=model_.RegionType(\n')
            self.Region.exportLiteral(outfile, level, name_='Region')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GroupSetting=[\n')
        level += 1
        for GroupSetting_ in self.GroupSetting:
            showIndent(outfile, level)
            outfile.write('model_.GroupSettingType(\n')
            GroupSetting_.exportLiteral(outfile, level, name_='GroupSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            Index_ = child_.text
            Index_ = self.gds_validate_string(Index_, node, 'Index')
            self.Index = Index_
        elif nodeName_ == 'Region':
            obj_ = RegionType.factory()
            obj_.build(child_)
            self.set_Region(obj_)
        elif nodeName_ == 'GroupSetting':
            obj_ = GroupSettingType.factory()
            obj_.build(child_)
            self.GroupSetting.append(obj_)
# end class SheetType


class RegionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartLineNo=None, EndLine=None, Step=None):
        self.StartLineNo = StartLineNo
        self.EndLine = EndLine
        self.Step = Step
    def factory(*args_, **kwargs_):
        if RegionType.subclass:
            return RegionType.subclass(*args_, **kwargs_)
        else:
            return RegionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartLineNo(self): return self.StartLineNo
    def set_StartLineNo(self, StartLineNo): self.StartLineNo = StartLineNo
    def get_EndLine(self): return self.EndLine
    def set_EndLine(self, EndLine): self.EndLine = EndLine
    def get_Step(self): return self.Step
    def set_Step(self, Step): self.Step = Step
    def export(self, outfile, level, namespace_='', name_='RegionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegionType', fromsubclass_=False):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('<%sStartLineNo>%s</%sStartLineNo>\n' % (namespace_, self.gds_format_integer(self.StartLineNo, input_name='StartLineNo'), namespace_))
        if self.EndLine is not None:
            self.EndLine.export(outfile, level, namespace_, name_='EndLine', )
        if self.Step is not None:
            showIndent(outfile, level)
            outfile.write('<%sStep>%s</%sStep>\n' % (namespace_, self.gds_format_string(quote_xml(self.Step).encode(ExternalEncoding), input_name='Step'), namespace_))
    def hasContent_(self):
        if (
            self.StartLineNo is not None or
            self.EndLine is not None or
            self.Step is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('StartLineNo=%d,\n' % self.StartLineNo)
        if self.EndLine is not None:
            showIndent(outfile, level)
            outfile.write('EndLine=model_.EndLineType1(\n')
            self.EndLine.exportLiteral(outfile, level, name_='EndLine')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Step is not None:
            showIndent(outfile, level)
            outfile.write('Step=%s,\n' % quote_python(self.Step).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartLineNo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLineNo')
            self.StartLineNo = ival_
        elif nodeName_ == 'EndLine':
            obj_ = EndLineType1.factory()
            obj_.build(child_)
            self.set_EndLine(obj_)
        elif nodeName_ == 'Step':
            Step_ = child_.text
            Step_ = self.gds_validate_string(Step_, node, 'Step')
            self.Step = Step_
# end class RegionType


class EndLineType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MaxBlankNumber=None, EndLineRegex=None):
        self.MaxBlankNumber = MaxBlankNumber
        self.EndLineRegex = EndLineRegex
    def factory(*args_, **kwargs_):
        if EndLineType1.subclass:
            return EndLineType1.subclass(*args_, **kwargs_)
        else:
            return EndLineType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaxBlankNumber(self): return self.MaxBlankNumber
    def set_MaxBlankNumber(self, MaxBlankNumber): self.MaxBlankNumber = MaxBlankNumber
    def get_EndLineRegex(self): return self.EndLineRegex
    def set_EndLineRegex(self, EndLineRegex): self.EndLineRegex = EndLineRegex
    def export(self, outfile, level, namespace_='', name_='EndLineType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineType1', fromsubclass_=False):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxBlankNumber>%s</%sMaxBlankNumber>\n' % (namespace_, self.gds_format_integer(self.MaxBlankNumber, input_name='MaxBlankNumber'), namespace_))
        if self.EndLineRegex is not None:
            self.EndLineRegex.export(outfile, level, namespace_, name_='EndLineRegex')
    def hasContent_(self):
        if (
            self.MaxBlankNumber is not None or
            self.EndLineRegex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('MaxBlankNumber=%d,\n' % self.MaxBlankNumber)
        if self.EndLineRegex is not None:
            showIndent(outfile, level)
            outfile.write('EndLineRegex=model_.EndLineRegexType1(\n')
            self.EndLineRegex.exportLiteral(outfile, level, name_='EndLineRegex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaxBlankNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxBlankNumber')
            self.MaxBlankNumber = ival_
        elif nodeName_ == 'EndLineRegex':
            obj_ = EndLineRegexType1.factory()
            obj_.build(child_)
            self.set_EndLineRegex(obj_)
# end class EndLineType1


class EndLineRegexType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, RegexExp=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.RegexExp = RegexExp
    def factory(*args_, **kwargs_):
        if EndLineRegexType1.subclass:
            return EndLineRegexType1.subclass(*args_, **kwargs_)
        else:
            return EndLineRegexType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_RegexExp(self): return self.RegexExp
    def set_RegexExp(self, RegexExp): self.RegexExp = RegexExp
    def export(self, outfile, level, namespace_='', name_='EndLineRegexType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineRegexType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineRegexType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineRegexType1', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('<%sRegexExp>%s</%sRegexExp>\n' % (namespace_, self.gds_format_string(quote_xml(self.RegexExp).encode(ExternalEncoding), input_name='RegexExp'), namespace_))
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.RegexExp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineRegexType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('RegexExp=%s,\n' % quote_python(self.RegexExp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'RegexExp':
            RegexExp_ = child_.text
            RegexExp_ = self.gds_validate_string(RegexExp_, node, 'RegexExp')
            self.RegexExp = RegexExp_
# end class EndLineRegexType1


class GroupSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KeySetting=None, ValueSetting=None):
        self.KeySetting = KeySetting
        self.ValueSetting = ValueSetting
    def factory(*args_, **kwargs_):
        if GroupSettingType.subclass:
            return GroupSettingType.subclass(*args_, **kwargs_)
        else:
            return GroupSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeySetting(self): return self.KeySetting
    def set_KeySetting(self, KeySetting): self.KeySetting = KeySetting
    def get_ValueSetting(self): return self.ValueSetting
    def set_ValueSetting(self, ValueSetting): self.ValueSetting = ValueSetting
    def export(self, outfile, level, namespace_='', name_='GroupSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupSettingType', fromsubclass_=False):
        if self.KeySetting is not None:
            self.KeySetting.export(outfile, level, namespace_, name_='KeySetting', )
        if self.ValueSetting is not None:
            self.ValueSetting.export(outfile, level, namespace_, name_='ValueSetting')
    def hasContent_(self):
        if (
            self.KeySetting is not None or
            self.ValueSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeySetting is not None:
            showIndent(outfile, level)
            outfile.write('KeySetting=model_.KeySettingType(\n')
            self.KeySetting.exportLiteral(outfile, level, name_='KeySetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ValueSetting is not None:
            showIndent(outfile, level)
            outfile.write('ValueSetting=model_.ValueSettingType(\n')
            self.ValueSetting.exportLiteral(outfile, level, name_='ValueSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeySetting':
            obj_ = KeySettingType.factory()
            obj_.build(child_)
            self.set_KeySetting(obj_)
        elif nodeName_ == 'ValueSetting':
            obj_ = ValueSettingType.factory()
            obj_.build(child_)
            self.set_ValueSetting(obj_)
# end class GroupSettingType


class KeySettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if KeySettingType.subclass:
            return KeySettingType.subclass(*args_, **kwargs_)
        else:
            return KeySettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='KeySettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeySettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeySettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeySettingType', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeySettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class KeySettingType


class DataFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType.subclass:
            return DataFieldType.subclass(*args_, **kwargs_)
        else:
            return DataFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def export(self, outfile, level, namespace_='', name_='DataFieldType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType7(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType7.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType


class ValuePatternType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType7.subclass:
            return ValuePatternType7.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType7', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType7')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType7', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType7'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType7(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType7.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType7


class LocationType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType7.subclass:
            return LocationType7.subclass(*args_, **kwargs_)
        else:
            return LocationType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType7', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType7')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType7', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType7'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType7(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType7.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType7


class FixedLocationType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType7.subclass:
            return FixedLocationType7.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType7', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType7')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType7', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType7'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType7


class ValueSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if ValueSettingType.subclass:
            return ValueSettingType.subclass(*args_, **kwargs_)
        else:
            return ValueSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='ValueSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValueSettingType', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType1(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType1.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class ValueSettingType


class DataFieldType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, DUid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.DUid = _cast(None, DUid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType1.subclass:
            return DataFieldType1.subclass(*args_, **kwargs_)
        else:
            return DataFieldType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def get_DUid(self): return self.DUid
    def set_DUid(self, DUid): self.DUid = DUid
    def export(self, outfile, level, namespace_='', name_='DataFieldType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType1'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            outfile.write(' DUid=%s' % (self.gds_format_string(quote_attrib(self.DUid).encode(ExternalEncoding), input_name='DUid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType1', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            showIndent(outfile, level)
            outfile.write('DUid = "%s",\n' % (self.DUid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType8(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
        value = find_attr_value_('DUid', node)
        if value is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            self.DUid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType8.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType1


class ValuePatternType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType8.subclass:
            return ValuePatternType8.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType8', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType8')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType8', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType8'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType8(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType8.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType8


class LocationType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType8.subclass:
            return LocationType8.subclass(*args_, **kwargs_)
        else:
            return LocationType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType8', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType8')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType8', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType8'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType8(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType8.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType8


class FixedLocationType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType8.subclass:
            return FixedLocationType8.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType8', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType8')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType8', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType8'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType8


class TxtSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Orientation=None, Delimiter=None, QuoteChar=None, Region=None, GroupSetting=None):
        self.Orientation = Orientation
        self.Delimiter = Delimiter
        self.QuoteChar = QuoteChar
        self.Region = Region
        if GroupSetting is None:
            self.GroupSetting = []
        else:
            self.GroupSetting = GroupSetting
    def factory(*args_, **kwargs_):
        if TxtSettingType.subclass:
            return TxtSettingType.subclass(*args_, **kwargs_)
        else:
            return TxtSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_QuoteChar(self): return self.QuoteChar
    def set_QuoteChar(self, QuoteChar): self.QuoteChar = QuoteChar
    def get_Region(self): return self.Region
    def set_Region(self, Region): self.Region = Region
    def get_GroupSetting(self): return self.GroupSetting
    def set_GroupSetting(self, GroupSetting): self.GroupSetting = GroupSetting
    def add_GroupSetting(self, value): self.GroupSetting.append(value)
    def insert_GroupSetting(self, index, value): self.GroupSetting[index] = value
    def export(self, outfile, level, namespace_='', name_='TxtSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TxtSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TxtSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TxtSettingType', fromsubclass_=False):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrientation>%s</%sOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Orientation).encode(ExternalEncoding), input_name='Orientation'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
        if self.QuoteChar is not None:
            showIndent(outfile, level)
            outfile.write('<%sQuoteChar>%s</%sQuoteChar>\n' % (namespace_, self.gds_format_string(quote_xml(self.QuoteChar).encode(ExternalEncoding), input_name='QuoteChar'), namespace_))
        if self.Region is not None:
            self.Region.export(outfile, level, namespace_, name_='Region', )
        for GroupSetting_ in self.GroupSetting:
            GroupSetting_.export(outfile, level, namespace_, name_='GroupSetting')
    def hasContent_(self):
        if (
            self.Orientation is not None or
            self.Delimiter is not None or
            self.QuoteChar is not None or
            self.Region is not None or
            self.GroupSetting
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TxtSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('Orientation=%s,\n' % quote_python(self.Orientation).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
        if self.QuoteChar is not None:
            showIndent(outfile, level)
            outfile.write('QuoteChar=%s,\n' % quote_python(self.QuoteChar).encode(ExternalEncoding))
        if self.Region is not None:
            showIndent(outfile, level)
            outfile.write('Region=model_.RegionType1(\n')
            self.Region.exportLiteral(outfile, level, name_='Region')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GroupSetting=[\n')
        level += 1
        for GroupSetting_ in self.GroupSetting:
            showIndent(outfile, level)
            outfile.write('model_.GroupSettingType1(\n')
            GroupSetting_.exportLiteral(outfile, level, name_='GroupSettingType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Orientation':
            Orientation_ = child_.text
            Orientation_ = self.gds_validate_string(Orientation_, node, 'Orientation')
            self.Orientation = Orientation_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
        elif nodeName_ == 'QuoteChar':
            QuoteChar_ = child_.text
            QuoteChar_ = self.gds_validate_string(QuoteChar_, node, 'QuoteChar')
            self.QuoteChar = QuoteChar_
        elif nodeName_ == 'Region':
            obj_ = RegionType1.factory()
            obj_.build(child_)
            self.set_Region(obj_)
        elif nodeName_ == 'GroupSetting':
            obj_ = GroupSettingType1.factory()
            obj_.build(child_)
            self.GroupSetting.append(obj_)
# end class TxtSettingType


class Orientation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Orientation.subclass:
            return Orientation.subclass(*args_, **kwargs_)
        else:
            return Orientation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Orientation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Orientation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Orientation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Orientation', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Orientation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Orientation


class RegionType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartLineNo=None, EndLine=None):
        self.StartLineNo = StartLineNo
        self.EndLine = EndLine
    def factory(*args_, **kwargs_):
        if RegionType1.subclass:
            return RegionType1.subclass(*args_, **kwargs_)
        else:
            return RegionType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartLineNo(self): return self.StartLineNo
    def set_StartLineNo(self, StartLineNo): self.StartLineNo = StartLineNo
    def get_EndLine(self): return self.EndLine
    def set_EndLine(self, EndLine): self.EndLine = EndLine
    def export(self, outfile, level, namespace_='', name_='RegionType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegionType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegionType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegionType1', fromsubclass_=False):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('<%sStartLineNo>%s</%sStartLineNo>\n' % (namespace_, self.gds_format_integer(self.StartLineNo, input_name='StartLineNo'), namespace_))
        if self.EndLine is not None:
            self.EndLine.export(outfile, level, namespace_, name_='EndLine', )
    def hasContent_(self):
        if (
            self.StartLineNo is not None or
            self.EndLine is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegionType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('StartLineNo=%d,\n' % self.StartLineNo)
        if self.EndLine is not None:
            showIndent(outfile, level)
            outfile.write('EndLine=model_.EndLineType2(\n')
            self.EndLine.exportLiteral(outfile, level, name_='EndLine')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartLineNo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLineNo')
            self.StartLineNo = ival_
        elif nodeName_ == 'EndLine':
            obj_ = EndLineType2.factory()
            obj_.build(child_)
            self.set_EndLine(obj_)
# end class RegionType1


class EndLineType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MaxBlankNumber=None, EndLineRegex=None):
        self.MaxBlankNumber = MaxBlankNumber
        self.EndLineRegex = EndLineRegex
    def factory(*args_, **kwargs_):
        if EndLineType2.subclass:
            return EndLineType2.subclass(*args_, **kwargs_)
        else:
            return EndLineType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaxBlankNumber(self): return self.MaxBlankNumber
    def set_MaxBlankNumber(self, MaxBlankNumber): self.MaxBlankNumber = MaxBlankNumber
    def get_EndLineRegex(self): return self.EndLineRegex
    def set_EndLineRegex(self, EndLineRegex): self.EndLineRegex = EndLineRegex
    def export(self, outfile, level, namespace_='', name_='EndLineType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineType2', fromsubclass_=False):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxBlankNumber>%s</%sMaxBlankNumber>\n' % (namespace_, self.gds_format_integer(self.MaxBlankNumber, input_name='MaxBlankNumber'), namespace_))
        if self.EndLineRegex is not None:
            self.EndLineRegex.export(outfile, level, namespace_, name_='EndLineRegex')
    def hasContent_(self):
        if (
            self.MaxBlankNumber is not None or
            self.EndLineRegex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('MaxBlankNumber=%d,\n' % self.MaxBlankNumber)
        if self.EndLineRegex is not None:
            showIndent(outfile, level)
            outfile.write('EndLineRegex=model_.EndLineRegexType2(\n')
            self.EndLineRegex.exportLiteral(outfile, level, name_='EndLineRegex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaxBlankNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxBlankNumber')
            self.MaxBlankNumber = ival_
        elif nodeName_ == 'EndLineRegex':
            obj_ = EndLineRegexType2.factory()
            obj_.build(child_)
            self.set_EndLineRegex(obj_)
# end class EndLineType2


class EndLineRegexType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, RegexExp=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.RegexExp = RegexExp
    def factory(*args_, **kwargs_):
        if EndLineRegexType2.subclass:
            return EndLineRegexType2.subclass(*args_, **kwargs_)
        else:
            return EndLineRegexType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_RegexExp(self): return self.RegexExp
    def set_RegexExp(self, RegexExp): self.RegexExp = RegexExp
    def export(self, outfile, level, namespace_='', name_='EndLineRegexType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineRegexType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineRegexType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineRegexType2', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('<%sRegexExp>%s</%sRegexExp>\n' % (namespace_, self.gds_format_string(quote_xml(self.RegexExp).encode(ExternalEncoding), input_name='RegexExp'), namespace_))
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.RegexExp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineRegexType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('RegexExp=%s,\n' % quote_python(self.RegexExp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'RegexExp':
            RegexExp_ = child_.text
            RegexExp_ = self.gds_validate_string(RegexExp_, node, 'RegexExp')
            self.RegexExp = RegexExp_
# end class EndLineRegexType2


class GroupSettingType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KeySetting=None, ValueSetting=None):
        self.KeySetting = KeySetting
        self.ValueSetting = ValueSetting
    def factory(*args_, **kwargs_):
        if GroupSettingType1.subclass:
            return GroupSettingType1.subclass(*args_, **kwargs_)
        else:
            return GroupSettingType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeySetting(self): return self.KeySetting
    def set_KeySetting(self, KeySetting): self.KeySetting = KeySetting
    def get_ValueSetting(self): return self.ValueSetting
    def set_ValueSetting(self, ValueSetting): self.ValueSetting = ValueSetting
    def export(self, outfile, level, namespace_='', name_='GroupSettingType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupSettingType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupSettingType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupSettingType1', fromsubclass_=False):
        if self.KeySetting is not None:
            self.KeySetting.export(outfile, level, namespace_, name_='KeySetting', )
        if self.ValueSetting is not None:
            self.ValueSetting.export(outfile, level, namespace_, name_='ValueSetting')
    def hasContent_(self):
        if (
            self.KeySetting is not None or
            self.ValueSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupSettingType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeySetting is not None:
            showIndent(outfile, level)
            outfile.write('KeySetting=model_.KeySettingType1(\n')
            self.KeySetting.exportLiteral(outfile, level, name_='KeySetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ValueSetting is not None:
            showIndent(outfile, level)
            outfile.write('ValueSetting=model_.ValueSettingType1(\n')
            self.ValueSetting.exportLiteral(outfile, level, name_='ValueSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeySetting':
            obj_ = KeySettingType1.factory()
            obj_.build(child_)
            self.set_KeySetting(obj_)
        elif nodeName_ == 'ValueSetting':
            obj_ = ValueSettingType1.factory()
            obj_.build(child_)
            self.set_ValueSetting(obj_)
# end class GroupSettingType1


class KeySettingType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if KeySettingType1.subclass:
            return KeySettingType1.subclass(*args_, **kwargs_)
        else:
            return KeySettingType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='KeySettingType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeySettingType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeySettingType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeySettingType1', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeySettingType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType2(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType2.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class KeySettingType1


class DataFieldType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType2.subclass:
            return DataFieldType2.subclass(*args_, **kwargs_)
        else:
            return DataFieldType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def export(self, outfile, level, namespace_='', name_='DataFieldType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType2'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType2', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType9(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType9.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType2


class ValuePatternType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType9.subclass:
            return ValuePatternType9.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType9', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType9')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType9', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType9'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType9(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType9.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType9


class LocationType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType9.subclass:
            return LocationType9.subclass(*args_, **kwargs_)
        else:
            return LocationType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType9', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType9')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType9', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType9'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType9(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType9.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType9


class FixedLocationType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType9.subclass:
            return FixedLocationType9.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType9', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType9')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType9', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType9'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType9


class ValueSettingType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if ValueSettingType1.subclass:
            return ValueSettingType1.subclass(*args_, **kwargs_)
        else:
            return ValueSettingType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='ValueSettingType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueSettingType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueSettingType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValueSettingType1', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueSettingType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType3(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType3.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class ValueSettingType1


class DataFieldType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, DUid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.DUid = _cast(None, DUid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType3.subclass:
            return DataFieldType3.subclass(*args_, **kwargs_)
        else:
            return DataFieldType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def get_DUid(self): return self.DUid
    def set_DUid(self, DUid): self.DUid = DUid
    def export(self, outfile, level, namespace_='', name_='DataFieldType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType3'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            outfile.write(' DUid=%s' % (self.gds_format_string(quote_attrib(self.DUid).encode(ExternalEncoding), input_name='DUid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType3', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            showIndent(outfile, level)
            outfile.write('DUid = "%s",\n' % (self.DUid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType10(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
        value = find_attr_value_('DUid', node)
        if value is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            self.DUid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType10.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType3


class ValuePatternType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType10.subclass:
            return ValuePatternType10.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType10', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType10')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType10', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType10'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType10(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType10.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType10


class LocationType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType10.subclass:
            return LocationType10.subclass(*args_, **kwargs_)
        else:
            return LocationType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType10', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType10')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType10', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType10'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType10(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType10.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType10


class FixedLocationType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType10.subclass:
            return FixedLocationType10.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType10', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType10')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType10'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType10', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType10'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType10


class XmlSettingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, XSLTPath=None, Delimiter=None, LineBreak=None, ExcelSetting=None, TxtSetting=None):
        self.XSLTPath = XSLTPath
        self.Delimiter = Delimiter
        self.LineBreak = LineBreak
        self.ExcelSetting = ExcelSetting
        self.TxtSetting = TxtSetting
    def factory(*args_, **kwargs_):
        if XmlSettingType.subclass:
            return XmlSettingType.subclass(*args_, **kwargs_)
        else:
            return XmlSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XSLTPath(self): return self.XSLTPath
    def set_XSLTPath(self, XSLTPath): self.XSLTPath = XSLTPath
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_LineBreak(self): return self.LineBreak
    def set_LineBreak(self, LineBreak): self.LineBreak = LineBreak
    def get_ExcelSetting(self): return self.ExcelSetting
    def set_ExcelSetting(self, ExcelSetting): self.ExcelSetting = ExcelSetting
    def get_TxtSetting(self): return self.TxtSetting
    def set_TxtSetting(self, TxtSetting): self.TxtSetting = TxtSetting
    def export(self, outfile, level, namespace_='', name_='XmlSettingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XmlSettingType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XmlSettingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XmlSettingType', fromsubclass_=False):
        if self.XSLTPath is not None:
            showIndent(outfile, level)
            outfile.write('<%sXSLTPath>%s</%sXSLTPath>\n' % (namespace_, self.gds_format_string(quote_xml(self.XSLTPath).encode(ExternalEncoding), input_name='XSLTPath'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
        if self.LineBreak is not None:
            showIndent(outfile, level)
            outfile.write('<%sLineBreak>%s</%sLineBreak>\n' % (namespace_, self.gds_format_string(quote_xml(self.LineBreak).encode(ExternalEncoding), input_name='LineBreak'), namespace_))
        if self.ExcelSetting is not None:
            self.ExcelSetting.export(outfile, level, namespace_, name_='ExcelSetting')
        if self.TxtSetting is not None:
            self.TxtSetting.export(outfile, level, namespace_, name_='TxtSetting')
    def hasContent_(self):
        if (
            self.XSLTPath is not None or
            self.Delimiter is not None or
            self.LineBreak is not None or
            self.ExcelSetting is not None or
            self.TxtSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XmlSettingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.XSLTPath is not None:
            showIndent(outfile, level)
            outfile.write('XSLTPath=%s,\n' % quote_python(self.XSLTPath).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
        if self.LineBreak is not None:
            showIndent(outfile, level)
            outfile.write('LineBreak=%s,\n' % quote_python(self.LineBreak).encode(ExternalEncoding))
        if self.ExcelSetting is not None:
            showIndent(outfile, level)
            outfile.write('ExcelSetting=model_.ExcelSettingType1(\n')
            self.ExcelSetting.exportLiteral(outfile, level, name_='ExcelSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TxtSetting is not None:
            showIndent(outfile, level)
            outfile.write('TxtSetting=model_.TxtSettingType1(\n')
            self.TxtSetting.exportLiteral(outfile, level, name_='TxtSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XSLTPath':
            XSLTPath_ = child_.text
            XSLTPath_ = self.gds_validate_string(XSLTPath_, node, 'XSLTPath')
            self.XSLTPath = XSLTPath_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
        elif nodeName_ == 'LineBreak':
            LineBreak_ = child_.text
            LineBreak_ = self.gds_validate_string(LineBreak_, node, 'LineBreak')
            self.LineBreak = LineBreak_
        elif nodeName_ == 'ExcelSetting':
            obj_ = ExcelSettingType1.factory()
            obj_.build(child_)
            self.set_ExcelSetting(obj_)
        elif nodeName_ == 'TxtSetting':
            obj_ = TxtSettingType1.factory()
            obj_.build(child_)
            self.set_TxtSetting(obj_)
# end class XmlSettingType


class XSLTPath(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if XSLTPath.subclass:
            return XSLTPath.subclass(*args_, **kwargs_)
        else:
            return XSLTPath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='XSLTPath', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XSLTPath')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XSLTPath'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XSLTPath', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XSLTPath'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class XSLTPath


class LineBreak(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if LineBreak.subclass:
            return LineBreak.subclass(*args_, **kwargs_)
        else:
            return LineBreak(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='LineBreak', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LineBreak')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LineBreak'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LineBreak', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LineBreak'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LineBreak


class ExcelSettingType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Orientation=None, Sheet=None):
        self.Orientation = Orientation
        if Sheet is None:
            self.Sheet = []
        else:
            self.Sheet = Sheet
    def factory(*args_, **kwargs_):
        if ExcelSettingType1.subclass:
            return ExcelSettingType1.subclass(*args_, **kwargs_)
        else:
            return ExcelSettingType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_Sheet(self): return self.Sheet
    def set_Sheet(self, Sheet): self.Sheet = Sheet
    def add_Sheet(self, value): self.Sheet.append(value)
    def insert_Sheet(self, index, value): self.Sheet[index] = value
    def export(self, outfile, level, namespace_='', name_='ExcelSettingType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExcelSettingType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExcelSettingType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExcelSettingType1', fromsubclass_=False):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrientation>%s</%sOrientation>\n' % (namespace_, self.gds_format_integer(self.Orientation, input_name='Orientation'), namespace_))
        for Sheet_ in self.Sheet:
            Sheet_.export(outfile, level, namespace_, name_='Sheet')
    def hasContent_(self):
        if (
            self.Orientation is not None or
            self.Sheet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExcelSettingType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('Orientation=%d,\n' % self.Orientation)
        showIndent(outfile, level)
        outfile.write('Sheet=[\n')
        level += 1
        for Sheet_ in self.Sheet:
            showIndent(outfile, level)
            outfile.write('model_.SheetType1(\n')
            Sheet_.exportLiteral(outfile, level, name_='SheetType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Orientation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Orientation')
            self.Orientation = ival_
        elif nodeName_ == 'Sheet':
            obj_ = SheetType1.factory()
            obj_.build(child_)
            self.Sheet.append(obj_)
# end class ExcelSettingType1


class SheetType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Index=None, Region=None, GroupSetting=None):
        self.Index = Index
        self.Region = Region
        if GroupSetting is None:
            self.GroupSetting = []
        else:
            self.GroupSetting = GroupSetting
    def factory(*args_, **kwargs_):
        if SheetType1.subclass:
            return SheetType1.subclass(*args_, **kwargs_)
        else:
            return SheetType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Region(self): return self.Region
    def set_Region(self, Region): self.Region = Region
    def get_GroupSetting(self): return self.GroupSetting
    def set_GroupSetting(self, GroupSetting): self.GroupSetting = GroupSetting
    def add_GroupSetting(self, value): self.GroupSetting.append(value)
    def insert_GroupSetting(self, index, value): self.GroupSetting[index] = value
    def export(self, outfile, level, namespace_='', name_='SheetType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SheetType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SheetType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SheetType1', fromsubclass_=False):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('<%sIndex>%s</%sIndex>\n' % (namespace_, self.gds_format_string(quote_xml(self.Index).encode(ExternalEncoding), input_name='Index'), namespace_))
        if self.Region is not None:
            self.Region.export(outfile, level, namespace_, name_='Region', )
        for GroupSetting_ in self.GroupSetting:
            GroupSetting_.export(outfile, level, namespace_, name_='GroupSetting')
    def hasContent_(self):
        if (
            self.Index is not None or
            self.Region is not None or
            self.GroupSetting
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SheetType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=%s,\n' % quote_python(self.Index).encode(ExternalEncoding))
        if self.Region is not None:
            showIndent(outfile, level)
            outfile.write('Region=model_.RegionType2(\n')
            self.Region.exportLiteral(outfile, level, name_='Region')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GroupSetting=[\n')
        level += 1
        for GroupSetting_ in self.GroupSetting:
            showIndent(outfile, level)
            outfile.write('model_.GroupSettingType2(\n')
            GroupSetting_.exportLiteral(outfile, level, name_='GroupSettingType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            Index_ = child_.text
            Index_ = self.gds_validate_string(Index_, node, 'Index')
            self.Index = Index_
        elif nodeName_ == 'Region':
            obj_ = RegionType2.factory()
            obj_.build(child_)
            self.set_Region(obj_)
        elif nodeName_ == 'GroupSetting':
            obj_ = GroupSettingType2.factory()
            obj_.build(child_)
            self.GroupSetting.append(obj_)
# end class SheetType1


class RegionType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartLineNo=None, EndLine=None):
        self.StartLineNo = StartLineNo
        self.EndLine = EndLine
    def factory(*args_, **kwargs_):
        if RegionType2.subclass:
            return RegionType2.subclass(*args_, **kwargs_)
        else:
            return RegionType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartLineNo(self): return self.StartLineNo
    def set_StartLineNo(self, StartLineNo): self.StartLineNo = StartLineNo
    def get_EndLine(self): return self.EndLine
    def set_EndLine(self, EndLine): self.EndLine = EndLine
    def export(self, outfile, level, namespace_='', name_='RegionType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegionType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegionType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegionType2', fromsubclass_=False):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('<%sStartLineNo>%s</%sStartLineNo>\n' % (namespace_, self.gds_format_integer(self.StartLineNo, input_name='StartLineNo'), namespace_))
        if self.EndLine is not None:
            self.EndLine.export(outfile, level, namespace_, name_='EndLine', )
    def hasContent_(self):
        if (
            self.StartLineNo is not None or
            self.EndLine is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegionType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('StartLineNo=%d,\n' % self.StartLineNo)
        if self.EndLine is not None:
            showIndent(outfile, level)
            outfile.write('EndLine=model_.EndLineType3(\n')
            self.EndLine.exportLiteral(outfile, level, name_='EndLine')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartLineNo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLineNo')
            self.StartLineNo = ival_
        elif nodeName_ == 'EndLine':
            obj_ = EndLineType3.factory()
            obj_.build(child_)
            self.set_EndLine(obj_)
# end class RegionType2


class EndLineType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MaxBlankNumber=None, EndLineRegex=None):
        self.MaxBlankNumber = MaxBlankNumber
        self.EndLineRegex = EndLineRegex
    def factory(*args_, **kwargs_):
        if EndLineType3.subclass:
            return EndLineType3.subclass(*args_, **kwargs_)
        else:
            return EndLineType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaxBlankNumber(self): return self.MaxBlankNumber
    def set_MaxBlankNumber(self, MaxBlankNumber): self.MaxBlankNumber = MaxBlankNumber
    def get_EndLineRegex(self): return self.EndLineRegex
    def set_EndLineRegex(self, EndLineRegex): self.EndLineRegex = EndLineRegex
    def export(self, outfile, level, namespace_='', name_='EndLineType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineType3', fromsubclass_=False):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxBlankNumber>%s</%sMaxBlankNumber>\n' % (namespace_, self.gds_format_integer(self.MaxBlankNumber, input_name='MaxBlankNumber'), namespace_))
        if self.EndLineRegex is not None:
            self.EndLineRegex.export(outfile, level, namespace_, name_='EndLineRegex')
    def hasContent_(self):
        if (
            self.MaxBlankNumber is not None or
            self.EndLineRegex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('MaxBlankNumber=%d,\n' % self.MaxBlankNumber)
        if self.EndLineRegex is not None:
            showIndent(outfile, level)
            outfile.write('EndLineRegex=model_.EndLineRegexType3(\n')
            self.EndLineRegex.exportLiteral(outfile, level, name_='EndLineRegex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaxBlankNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxBlankNumber')
            self.MaxBlankNumber = ival_
        elif nodeName_ == 'EndLineRegex':
            obj_ = EndLineRegexType3.factory()
            obj_.build(child_)
            self.set_EndLineRegex(obj_)
# end class EndLineType3


class EndLineRegexType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, RegexExp=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.RegexExp = RegexExp
    def factory(*args_, **kwargs_):
        if EndLineRegexType3.subclass:
            return EndLineRegexType3.subclass(*args_, **kwargs_)
        else:
            return EndLineRegexType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_RegexExp(self): return self.RegexExp
    def set_RegexExp(self, RegexExp): self.RegexExp = RegexExp
    def export(self, outfile, level, namespace_='', name_='EndLineRegexType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineRegexType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineRegexType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineRegexType3', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('<%sRegexExp>%s</%sRegexExp>\n' % (namespace_, self.gds_format_string(quote_xml(self.RegexExp).encode(ExternalEncoding), input_name='RegexExp'), namespace_))
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.RegexExp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineRegexType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('RegexExp=%s,\n' % quote_python(self.RegexExp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'RegexExp':
            RegexExp_ = child_.text
            RegexExp_ = self.gds_validate_string(RegexExp_, node, 'RegexExp')
            self.RegexExp = RegexExp_
# end class EndLineRegexType3


class GroupSettingType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KeySetting=None, ValueSetting=None):
        self.KeySetting = KeySetting
        self.ValueSetting = ValueSetting
    def factory(*args_, **kwargs_):
        if GroupSettingType2.subclass:
            return GroupSettingType2.subclass(*args_, **kwargs_)
        else:
            return GroupSettingType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeySetting(self): return self.KeySetting
    def set_KeySetting(self, KeySetting): self.KeySetting = KeySetting
    def get_ValueSetting(self): return self.ValueSetting
    def set_ValueSetting(self, ValueSetting): self.ValueSetting = ValueSetting
    def export(self, outfile, level, namespace_='', name_='GroupSettingType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupSettingType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupSettingType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupSettingType2', fromsubclass_=False):
        if self.KeySetting is not None:
            self.KeySetting.export(outfile, level, namespace_, name_='KeySetting', )
        if self.ValueSetting is not None:
            self.ValueSetting.export(outfile, level, namespace_, name_='ValueSetting')
    def hasContent_(self):
        if (
            self.KeySetting is not None or
            self.ValueSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupSettingType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeySetting is not None:
            showIndent(outfile, level)
            outfile.write('KeySetting=model_.KeySettingType2(\n')
            self.KeySetting.exportLiteral(outfile, level, name_='KeySetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ValueSetting is not None:
            showIndent(outfile, level)
            outfile.write('ValueSetting=model_.ValueSettingType2(\n')
            self.ValueSetting.exportLiteral(outfile, level, name_='ValueSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeySetting':
            obj_ = KeySettingType2.factory()
            obj_.build(child_)
            self.set_KeySetting(obj_)
        elif nodeName_ == 'ValueSetting':
            obj_ = ValueSettingType2.factory()
            obj_.build(child_)
            self.set_ValueSetting(obj_)
# end class GroupSettingType2


class KeySettingType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if KeySettingType2.subclass:
            return KeySettingType2.subclass(*args_, **kwargs_)
        else:
            return KeySettingType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='KeySettingType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeySettingType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeySettingType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeySettingType2', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeySettingType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType4(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType4')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType4.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class KeySettingType2


class DataFieldType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType4.subclass:
            return DataFieldType4.subclass(*args_, **kwargs_)
        else:
            return DataFieldType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def export(self, outfile, level, namespace_='', name_='DataFieldType4', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType4')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType4'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType4', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType11(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType11.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType4


class ValuePatternType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType11.subclass:
            return ValuePatternType11.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType11', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType11')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType11', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location', )
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormatType).encode(ExternalEncoding), input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType11'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType11(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%s,\n' % quote_python(self.DataFormatType).encode(ExternalEncoding))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType11.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            DataFormatType_ = child_.text
            DataFormatType_ = self.gds_validate_string(DataFormatType_, node, 'DataFormatType')
            self.DataFormatType = DataFormatType_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType11


class DataFormatType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if DataFormatType.subclass:
            return DataFormatType.subclass(*args_, **kwargs_)
        else:
            return DataFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='DataFormatType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFormatType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFormatType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataFormatType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFormatType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataFormatType


class LocationType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType11.subclass:
            return LocationType11.subclass(*args_, **kwargs_)
        else:
            return LocationType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType11', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType11')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType11', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType11'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType11(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType11.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType11


class FixedLocationType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType11.subclass:
            return FixedLocationType11.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType11', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType11')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType11', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType11'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType11


class ValueSettingType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if ValueSettingType2.subclass:
            return ValueSettingType2.subclass(*args_, **kwargs_)
        else:
            return ValueSettingType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='ValueSettingType2', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueSettingType2')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueSettingType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValueSettingType2', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueSettingType2'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType5(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType5')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType5.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class ValueSettingType2


class DataFieldType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, DUid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.DUid = _cast(None, DUid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType5.subclass:
            return DataFieldType5.subclass(*args_, **kwargs_)
        else:
            return DataFieldType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def get_DUid(self): return self.DUid
    def set_DUid(self, DUid): self.DUid = DUid
    def export(self, outfile, level, namespace_='', name_='DataFieldType5', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType5')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType5'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            outfile.write(' DUid=%s' % (self.gds_format_string(quote_attrib(self.DUid).encode(ExternalEncoding), input_name='DUid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType5', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType5'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            showIndent(outfile, level)
            outfile.write('DUid = "%s",\n' % (self.DUid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType12(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
        value = find_attr_value_('DUid', node)
        if value is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            self.DUid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType12.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType5


class ValuePatternType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType12.subclass:
            return ValuePatternType12.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType12', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType12')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType12', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType12'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType12(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType12.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType12


class LocationType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType12.subclass:
            return LocationType12.subclass(*args_, **kwargs_)
        else:
            return LocationType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType12', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType12')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType12', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType12'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType12(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType12.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType12


class FixedLocationType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType12.subclass:
            return FixedLocationType12.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType12', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType12')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType12', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType12'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType12


class TxtSettingType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Orientation=None, Delimiter=None, QuoteChar=None, Region=None, GroupSetting=None):
        self.Orientation = Orientation
        self.Delimiter = Delimiter
        self.QuoteChar = QuoteChar
        self.Region = Region
        if GroupSetting is None:
            self.GroupSetting = []
        else:
            self.GroupSetting = GroupSetting
    def factory(*args_, **kwargs_):
        if TxtSettingType1.subclass:
            return TxtSettingType1.subclass(*args_, **kwargs_)
        else:
            return TxtSettingType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Orientation(self): return self.Orientation
    def set_Orientation(self, Orientation): self.Orientation = Orientation
    def get_Delimiter(self): return self.Delimiter
    def set_Delimiter(self, Delimiter): self.Delimiter = Delimiter
    def get_QuoteChar(self): return self.QuoteChar
    def set_QuoteChar(self, QuoteChar): self.QuoteChar = QuoteChar
    def get_Region(self): return self.Region
    def set_Region(self, Region): self.Region = Region
    def get_GroupSetting(self): return self.GroupSetting
    def set_GroupSetting(self, GroupSetting): self.GroupSetting = GroupSetting
    def add_GroupSetting(self, value): self.GroupSetting.append(value)
    def insert_GroupSetting(self, index, value): self.GroupSetting[index] = value
    def export(self, outfile, level, namespace_='', name_='TxtSettingType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TxtSettingType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TxtSettingType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TxtSettingType1', fromsubclass_=False):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOrientation>%s</%sOrientation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Orientation).encode(ExternalEncoding), input_name='Orientation'), namespace_))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('<%sDelimiter>%s</%sDelimiter>\n' % (namespace_, self.gds_format_string(quote_xml(self.Delimiter).encode(ExternalEncoding), input_name='Delimiter'), namespace_))
        if self.QuoteChar is not None:
            showIndent(outfile, level)
            outfile.write('<%sQuoteChar>%s</%sQuoteChar>\n' % (namespace_, self.gds_format_string(quote_xml(self.QuoteChar).encode(ExternalEncoding), input_name='QuoteChar'), namespace_))
        if self.Region is not None:
            self.Region.export(outfile, level, namespace_, name_='Region', )
        for GroupSetting_ in self.GroupSetting:
            GroupSetting_.export(outfile, level, namespace_, name_='GroupSetting')
    def hasContent_(self):
        if (
            self.Orientation is not None or
            self.Delimiter is not None or
            self.QuoteChar is not None or
            self.Region is not None or
            self.GroupSetting
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TxtSettingType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Orientation is not None:
            showIndent(outfile, level)
            outfile.write('Orientation=%s,\n' % quote_python(self.Orientation).encode(ExternalEncoding))
        if self.Delimiter is not None:
            showIndent(outfile, level)
            outfile.write('Delimiter=%s,\n' % quote_python(self.Delimiter).encode(ExternalEncoding))
        if self.QuoteChar is not None:
            showIndent(outfile, level)
            outfile.write('QuoteChar=%s,\n' % quote_python(self.QuoteChar).encode(ExternalEncoding))
        if self.Region is not None:
            showIndent(outfile, level)
            outfile.write('Region=model_.RegionType3(\n')
            self.Region.exportLiteral(outfile, level, name_='Region')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('GroupSetting=[\n')
        level += 1
        for GroupSetting_ in self.GroupSetting:
            showIndent(outfile, level)
            outfile.write('model_.GroupSettingType3(\n')
            GroupSetting_.exportLiteral(outfile, level, name_='GroupSettingType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Orientation':
            Orientation_ = child_.text
            Orientation_ = self.gds_validate_string(Orientation_, node, 'Orientation')
            self.Orientation = Orientation_
        elif nodeName_ == 'Delimiter':
            Delimiter_ = child_.text
            Delimiter_ = self.gds_validate_string(Delimiter_, node, 'Delimiter')
            self.Delimiter = Delimiter_
        elif nodeName_ == 'QuoteChar':
            QuoteChar_ = child_.text
            QuoteChar_ = self.gds_validate_string(QuoteChar_, node, 'QuoteChar')
            self.QuoteChar = QuoteChar_
        elif nodeName_ == 'Region':
            obj_ = RegionType3.factory()
            obj_.build(child_)
            self.set_Region(obj_)
        elif nodeName_ == 'GroupSetting':
            obj_ = GroupSettingType3.factory()
            obj_.build(child_)
            self.GroupSetting.append(obj_)
# end class TxtSettingType1


class RegionType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StartLineNo=None, EndLine=None):
        self.StartLineNo = StartLineNo
        self.EndLine = EndLine
    def factory(*args_, **kwargs_):
        if RegionType3.subclass:
            return RegionType3.subclass(*args_, **kwargs_)
        else:
            return RegionType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartLineNo(self): return self.StartLineNo
    def set_StartLineNo(self, StartLineNo): self.StartLineNo = StartLineNo
    def get_EndLine(self): return self.EndLine
    def set_EndLine(self, EndLine): self.EndLine = EndLine
    def export(self, outfile, level, namespace_='', name_='RegionType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegionType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegionType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegionType3', fromsubclass_=False):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('<%sStartLineNo>%s</%sStartLineNo>\n' % (namespace_, self.gds_format_integer(self.StartLineNo, input_name='StartLineNo'), namespace_))
        if self.EndLine is not None:
            self.EndLine.export(outfile, level, namespace_, name_='EndLine', )
    def hasContent_(self):
        if (
            self.StartLineNo is not None or
            self.EndLine is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegionType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartLineNo is not None:
            showIndent(outfile, level)
            outfile.write('StartLineNo=%d,\n' % self.StartLineNo)
        if self.EndLine is not None:
            showIndent(outfile, level)
            outfile.write('EndLine=model_.EndLineType4(\n')
            self.EndLine.exportLiteral(outfile, level, name_='EndLine')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartLineNo':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StartLineNo')
            self.StartLineNo = ival_
        elif nodeName_ == 'EndLine':
            obj_ = EndLineType4.factory()
            obj_.build(child_)
            self.set_EndLine(obj_)
# end class RegionType3


class EndLineType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MaxBlankNumber=None, EndLineRegex=None):
        self.MaxBlankNumber = MaxBlankNumber
        self.EndLineRegex = EndLineRegex
    def factory(*args_, **kwargs_):
        if EndLineType4.subclass:
            return EndLineType4.subclass(*args_, **kwargs_)
        else:
            return EndLineType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MaxBlankNumber(self): return self.MaxBlankNumber
    def set_MaxBlankNumber(self, MaxBlankNumber): self.MaxBlankNumber = MaxBlankNumber
    def get_EndLineRegex(self): return self.EndLineRegex
    def set_EndLineRegex(self, EndLineRegex): self.EndLineRegex = EndLineRegex
    def export(self, outfile, level, namespace_='', name_='EndLineType4', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineType4')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineType4', fromsubclass_=False):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sMaxBlankNumber>%s</%sMaxBlankNumber>\n' % (namespace_, self.gds_format_integer(self.MaxBlankNumber, input_name='MaxBlankNumber'), namespace_))
        if self.EndLineRegex is not None:
            self.EndLineRegex.export(outfile, level, namespace_, name_='EndLineRegex')
    def hasContent_(self):
        if (
            self.MaxBlankNumber is not None or
            self.EndLineRegex is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MaxBlankNumber is not None:
            showIndent(outfile, level)
            outfile.write('MaxBlankNumber=%d,\n' % self.MaxBlankNumber)
        if self.EndLineRegex is not None:
            showIndent(outfile, level)
            outfile.write('EndLineRegex=model_.EndLineRegexType4(\n')
            self.EndLineRegex.exportLiteral(outfile, level, name_='EndLineRegex')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MaxBlankNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxBlankNumber')
            self.MaxBlankNumber = ival_
        elif nodeName_ == 'EndLineRegex':
            obj_ = EndLineRegexType4.factory()
            obj_.build(child_)
            self.set_EndLineRegex(obj_)
# end class EndLineType4


class EndLineRegexType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, RegexExp=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.RegexExp = RegexExp
    def factory(*args_, **kwargs_):
        if EndLineRegexType4.subclass:
            return EndLineRegexType4.subclass(*args_, **kwargs_)
        else:
            return EndLineRegexType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_RegexExp(self): return self.RegexExp
    def set_RegexExp(self, RegexExp): self.RegexExp = RegexExp
    def export(self, outfile, level, namespace_='', name_='EndLineRegexType4', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLineRegexType4')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndLineRegexType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EndLineRegexType4', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('<%sRegexExp>%s</%sRegexExp>\n' % (namespace_, self.gds_format_string(quote_xml(self.RegexExp).encode(ExternalEncoding), input_name='RegexExp'), namespace_))
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.RegexExp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLineRegexType4'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.RegexExp is not None:
            showIndent(outfile, level)
            outfile.write('RegexExp=%s,\n' % quote_python(self.RegexExp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'RegexExp':
            RegexExp_ = child_.text
            RegexExp_ = self.gds_validate_string(RegexExp_, node, 'RegexExp')
            self.RegexExp = RegexExp_
# end class EndLineRegexType4


class GroupSettingType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KeySetting=None, ValueSetting=None):
        self.KeySetting = KeySetting
        self.ValueSetting = ValueSetting
    def factory(*args_, **kwargs_):
        if GroupSettingType3.subclass:
            return GroupSettingType3.subclass(*args_, **kwargs_)
        else:
            return GroupSettingType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeySetting(self): return self.KeySetting
    def set_KeySetting(self, KeySetting): self.KeySetting = KeySetting
    def get_ValueSetting(self): return self.ValueSetting
    def set_ValueSetting(self, ValueSetting): self.ValueSetting = ValueSetting
    def export(self, outfile, level, namespace_='', name_='GroupSettingType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupSettingType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GroupSettingType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GroupSettingType3', fromsubclass_=False):
        if self.KeySetting is not None:
            self.KeySetting.export(outfile, level, namespace_, name_='KeySetting', )
        if self.ValueSetting is not None:
            self.ValueSetting.export(outfile, level, namespace_, name_='ValueSetting')
    def hasContent_(self):
        if (
            self.KeySetting is not None or
            self.ValueSetting is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GroupSettingType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeySetting is not None:
            showIndent(outfile, level)
            outfile.write('KeySetting=model_.KeySettingType3(\n')
            self.KeySetting.exportLiteral(outfile, level, name_='KeySetting')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ValueSetting is not None:
            showIndent(outfile, level)
            outfile.write('ValueSetting=model_.ValueSettingType3(\n')
            self.ValueSetting.exportLiteral(outfile, level, name_='ValueSetting')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeySetting':
            obj_ = KeySettingType3.factory()
            obj_.build(child_)
            self.set_KeySetting(obj_)
        elif nodeName_ == 'ValueSetting':
            obj_ = ValueSettingType3.factory()
            obj_.build(child_)
            self.set_ValueSetting(obj_)
# end class GroupSettingType3


class KeySettingType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if KeySettingType3.subclass:
            return KeySettingType3.subclass(*args_, **kwargs_)
        else:
            return KeySettingType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='KeySettingType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeySettingType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KeySettingType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KeySettingType3', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeySettingType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType6(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType6')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType6.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class KeySettingType3


class DataFieldType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType6.subclass:
            return DataFieldType6.subclass(*args_, **kwargs_)
        else:
            return DataFieldType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def export(self, outfile, level, namespace_='', name_='DataFieldType6', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType6')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType6'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType6', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType6'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType13(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType13.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType6


class ValuePatternType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType13.subclass:
            return ValuePatternType13.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType13', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType13')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType13', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormatType).encode(ExternalEncoding), input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType13'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType13(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%s,\n' % quote_python(self.DataFormatType).encode(ExternalEncoding))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType13.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            DataFormatType_ = child_.text
            DataFormatType_ = self.gds_validate_string(DataFormatType_, node, 'DataFormatType')
            self.DataFormatType = DataFormatType_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType13


class LocationType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType13.subclass:
            return LocationType13.subclass(*args_, **kwargs_)
        else:
            return LocationType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType13', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType13')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType13', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType13'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType13(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType13.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType13


class FixedLocationType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType13.subclass:
            return FixedLocationType13.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType13', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType13')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType13', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType13'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType13


class ValueSettingType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DataField=None):
        if DataField is None:
            self.DataField = []
        else:
            self.DataField = DataField
    def factory(*args_, **kwargs_):
        if ValueSettingType3.subclass:
            return ValueSettingType3.subclass(*args_, **kwargs_)
        else:
            return ValueSettingType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataField(self): return self.DataField
    def set_DataField(self, DataField): self.DataField = DataField
    def add_DataField(self, value): self.DataField.append(value)
    def insert_DataField(self, index, value): self.DataField[index] = value
    def export(self, outfile, level, namespace_='', name_='ValueSettingType3', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueSettingType3')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValueSettingType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValueSettingType3', fromsubclass_=False):
        for DataField_ in self.DataField:
            DataField_.export(outfile, level, namespace_, name_='DataField')
    def hasContent_(self):
        if (
            self.DataField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueSettingType3'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataField=[\n')
        level += 1
        for DataField_ in self.DataField:
            showIndent(outfile, level)
            outfile.write('model_.DataFieldType7(\n')
            DataField_.exportLiteral(outfile, level, name_='DataFieldType7')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataField':
            obj_ = DataFieldType7.factory()
            obj_.build(child_)
            self.DataField.append(obj_)
# end class ValueSettingType3


class DataFieldType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DFid=None, DUid=None, ValuePattern=None):
        self.DFid = _cast(None, DFid)
        self.DUid = _cast(None, DUid)
        self.ValuePattern = ValuePattern
    def factory(*args_, **kwargs_):
        if DataFieldType7.subclass:
            return DataFieldType7.subclass(*args_, **kwargs_)
        else:
            return DataFieldType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValuePattern(self): return self.ValuePattern
    def set_ValuePattern(self, ValuePattern): self.ValuePattern = ValuePattern
    def get_DFid(self): return self.DFid
    def set_DFid(self, DFid): self.DFid = DFid
    def get_DUid(self): return self.DUid
    def set_DUid(self, DUid): self.DUid = DUid
    def export(self, outfile, level, namespace_='', name_='DataFieldType7', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataFieldType7')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataFieldType7'):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            outfile.write(' DFid=%s' % (self.gds_format_string(quote_attrib(self.DFid).encode(ExternalEncoding), input_name='DFid'), ))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            outfile.write(' DUid=%s' % (self.gds_format_string(quote_attrib(self.DUid).encode(ExternalEncoding), input_name='DUid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DataFieldType7', fromsubclass_=False):
        if self.ValuePattern is not None:
            self.ValuePattern.export(outfile, level, namespace_, name_='ValuePattern', )
    def hasContent_(self):
        if (
            self.ValuePattern is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DataFieldType7'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DFid is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            showIndent(outfile, level)
            outfile.write('DFid = "%s",\n' % (self.DFid,))
        if self.DUid is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            showIndent(outfile, level)
            outfile.write('DUid = "%s",\n' % (self.DUid,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ValuePattern is not None:
            showIndent(outfile, level)
            outfile.write('ValuePattern=model_.ValuePatternType14(\n')
            self.ValuePattern.exportLiteral(outfile, level, name_='ValuePattern')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DFid', node)
        if value is not None and 'DFid' not in already_processed:
            already_processed.append('DFid')
            self.DFid = value
        value = find_attr_value_('DUid', node)
        if value is not None and 'DUid' not in already_processed:
            already_processed.append('DUid')
            self.DUid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ValuePattern':
            obj_ = ValuePatternType14.factory()
            obj_.build(child_)
            self.set_ValuePattern(obj_)
# end class DataFieldType7


class ValuePatternType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Location=None, DataFormatType=None, DataFormat=None, InvalidValues=None):
        self.Location = Location
        self.DataFormatType = DataFormatType
        self.DataFormat = DataFormat
        self.InvalidValues = InvalidValues
    def factory(*args_, **kwargs_):
        if ValuePatternType14.subclass:
            return ValuePatternType14.subclass(*args_, **kwargs_)
        else:
            return ValuePatternType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Location(self): return self.Location
    def set_Location(self, Location): self.Location = Location
    def get_DataFormatType(self): return self.DataFormatType
    def set_DataFormatType(self, DataFormatType): self.DataFormatType = DataFormatType
    def get_DataFormat(self): return self.DataFormat
    def set_DataFormat(self, DataFormat): self.DataFormat = DataFormat
    def get_InvalidValues(self): return self.InvalidValues
    def set_InvalidValues(self, InvalidValues): self.InvalidValues = InvalidValues
    def export(self, outfile, level, namespace_='', name_='ValuePatternType14', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuePatternType14')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ValuePatternType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ValuePatternType14', fromsubclass_=False):
        if self.Location is not None:
            self.Location.export(outfile, level, namespace_, name_='Location')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormatType>%s</%sDataFormatType>\n' % (namespace_, self.gds_format_integer(self.DataFormatType, input_name='DataFormatType'), namespace_))
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('<%sDataFormat>%s</%sDataFormat>\n' % (namespace_, self.gds_format_string(quote_xml(self.DataFormat).encode(ExternalEncoding), input_name='DataFormat'), namespace_))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('<%sInvalidValues>%s</%sInvalidValues>\n' % (namespace_, self.gds_format_string(quote_xml(self.InvalidValues).encode(ExternalEncoding), input_name='InvalidValues'), namespace_))
    def hasContent_(self):
        if (
            self.Location is not None or
            self.DataFormatType is not None or
            self.DataFormat is not None or
            self.InvalidValues is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValuePatternType14'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Location is not None:
            showIndent(outfile, level)
            outfile.write('Location=model_.LocationType14(\n')
            self.Location.exportLiteral(outfile, level, name_='Location')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataFormatType is not None:
            showIndent(outfile, level)
            outfile.write('DataFormatType=%d,\n' % self.DataFormatType)
        if self.DataFormat is not None:
            showIndent(outfile, level)
            outfile.write('DataFormat=%s,\n' % quote_python(self.DataFormat).encode(ExternalEncoding))
        if self.InvalidValues is not None:
            showIndent(outfile, level)
            outfile.write('InvalidValues=%s,\n' % quote_python(self.InvalidValues).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Location':
            obj_ = LocationType14.factory()
            obj_.build(child_)
            self.set_Location(obj_)
        elif nodeName_ == 'DataFormatType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DataFormatType')
            self.DataFormatType = ival_
        elif nodeName_ == 'DataFormat':
            DataFormat_ = child_.text
            DataFormat_ = self.gds_validate_string(DataFormat_, node, 'DataFormat')
            self.DataFormat = DataFormat_
        elif nodeName_ == 'InvalidValues':
            InvalidValues_ = child_.text
            InvalidValues_ = self.gds_validate_string(InvalidValues_, node, 'InvalidValues')
            self.InvalidValues = InvalidValues_
# end class ValuePatternType14


class LocationType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AbsoluteExpression=None, FixedLocation=None):
        self.AbsoluteExpression = AbsoluteExpression
        self.FixedLocation = FixedLocation
    def factory(*args_, **kwargs_):
        if LocationType14.subclass:
            return LocationType14.subclass(*args_, **kwargs_)
        else:
            return LocationType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteExpression(self): return self.AbsoluteExpression
    def set_AbsoluteExpression(self, AbsoluteExpression): self.AbsoluteExpression = AbsoluteExpression
    def get_FixedLocation(self): return self.FixedLocation
    def set_FixedLocation(self, FixedLocation): self.FixedLocation = FixedLocation
    def export(self, outfile, level, namespace_='', name_='LocationType14', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType14')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType14', fromsubclass_=False):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sAbsoluteExpression>%s</%sAbsoluteExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.AbsoluteExpression).encode(ExternalEncoding), input_name='AbsoluteExpression'), namespace_))
        if self.FixedLocation is not None:
            self.FixedLocation.export(outfile, level, namespace_, name_='FixedLocation', )
    def hasContent_(self):
        if (
            self.AbsoluteExpression is not None or
            self.FixedLocation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType14'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteExpression is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteExpression=%s,\n' % quote_python(self.AbsoluteExpression).encode(ExternalEncoding))
        if self.FixedLocation is not None:
            showIndent(outfile, level)
            outfile.write('FixedLocation=model_.FixedLocationType14(\n')
            self.FixedLocation.exportLiteral(outfile, level, name_='FixedLocation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteExpression':
            AbsoluteExpression_ = child_.text
            AbsoluteExpression_ = self.gds_validate_string(AbsoluteExpression_, node, 'AbsoluteExpression')
            self.AbsoluteExpression = AbsoluteExpression_
        elif nodeName_ == 'FixedLocation':
            obj_ = FixedLocationType14.factory()
            obj_.build(child_)
            self.set_FixedLocation(obj_)
# end class LocationType14


class FixedLocationType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RowNumber=None, ColumnNumber=None):
        self.RowNumber = RowNumber
        self.ColumnNumber = ColumnNumber
    def factory(*args_, **kwargs_):
        if FixedLocationType14.subclass:
            return FixedLocationType14.subclass(*args_, **kwargs_)
        else:
            return FixedLocationType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RowNumber(self): return self.RowNumber
    def set_RowNumber(self, RowNumber): self.RowNumber = RowNumber
    def get_ColumnNumber(self): return self.ColumnNumber
    def set_ColumnNumber(self, ColumnNumber): self.ColumnNumber = ColumnNumber
    def export(self, outfile, level, namespace_='', name_='FixedLocationType14', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedLocationType14')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedLocationType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedLocationType14', fromsubclass_=False):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sRowNumber>%s</%sRowNumber>\n' % (namespace_, self.gds_format_integer(self.RowNumber, input_name='RowNumber'), namespace_))
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sColumnNumber>%s</%sColumnNumber>\n' % (namespace_, self.gds_format_integer(self.ColumnNumber, input_name='ColumnNumber'), namespace_))
    def hasContent_(self):
        if (
            self.RowNumber is not None or
            self.ColumnNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FixedLocationType14'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RowNumber is not None:
            showIndent(outfile, level)
            outfile.write('RowNumber=%d,\n' % self.RowNumber)
        if self.ColumnNumber is not None:
            showIndent(outfile, level)
            outfile.write('ColumnNumber=%d,\n' % self.ColumnNumber)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RowNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RowNumber')
            self.RowNumber = ival_
        elif nodeName_ == 'ColumnNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ColumnNumber')
            self.ColumnNumber = ival_
# end class FixedLocationType14


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ParsingConfig'
        rootClass = ParsingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ParsingConfig'
        rootClass = ParsingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="ParsingConfig",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ParsingConfig'
        rootClass = ParsingConfig
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from parsrsing import *\n\n')
    sys.stdout.write('import parsrsing as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbsoluteExpression",
    "CellStyleType",
    "CellStyleType1",
    "ColIndex",
    "ColSettingType",
    "DataFieldType",
    "DataFieldType1",
    "DataFieldType2",
    "DataFieldType3",
    "DataFieldType4",
    "DataFieldType5",
    "DataFieldType6",
    "DataFieldType7",
    "DataFormatType",
    "Delimiter",
    "EndLineRegexType",
    "EndLineRegexType1",
    "EndLineRegexType2",
    "EndLineRegexType3",
    "EndLineRegexType4",
    "EndLineType",
    "EndLineType1",
    "EndLineType2",
    "EndLineType3",
    "EndLineType4",
    "ExcelSettingType",
    "ExcelSettingType1",
    "FixedLocationType",
    "FixedLocationType1",
    "FixedLocationType10",
    "FixedLocationType11",
    "FixedLocationType12",
    "FixedLocationType13",
    "FixedLocationType14",
    "FixedLocationType2",
    "FixedLocationType3",
    "FixedLocationType4",
    "FixedLocationType5",
    "FixedLocationType6",
    "FixedLocationType7",
    "FixedLocationType8",
    "FixedLocationType9",
    "Function",
    "GroupSettingType",
    "GroupSettingType1",
    "GroupSettingType2",
    "GroupSettingType3",
    "IdtSettingType",
    "Index",
    "KeySettingType",
    "KeySettingType1",
    "KeySettingType2",
    "KeySettingType3",
    "LineBreak",
    "LineStyleType",
    "LineStyleType1",
    "LocationType",
    "LocationType1",
    "LocationType10",
    "LocationType11",
    "LocationType12",
    "LocationType13",
    "LocationType14",
    "LocationType2",
    "LocationType3",
    "LocationType4",
    "LocationType5",
    "LocationType6",
    "LocationType7",
    "LocationType8",
    "LocationType9",
    "Orientation",
    "ParsingConfig",
    "PointSettingType",
    "PointStyleType",
    "PointStyleType1",
    "PreExcelSettingType",
    "PreRegionType",
    "PreSheetType",
    "PreSpecialType",
    "PretreatmentType",
    "RegexExp",
    "RegionType",
    "RegionType1",
    "RegionType2",
    "RegionType3",
    "RowIndex",
    "RowSettingType",
    "SheetType",
    "SheetType1",
    "StartLineType",
    "Step",
    "TxtSettingType",
    "TxtSettingType1",
    "ValuePatternType",
    "ValuePatternType1",
    "ValuePatternType10",
    "ValuePatternType11",
    "ValuePatternType12",
    "ValuePatternType13",
    "ValuePatternType14",
    "ValuePatternType2",
    "ValuePatternType3",
    "ValuePatternType4",
    "ValuePatternType5",
    "ValuePatternType6",
    "ValuePatternType7",
    "ValuePatternType8",
    "ValuePatternType9",
    "ValueSettingType",
    "ValueSettingType1",
    "ValueSettingType2",
    "ValueSettingType3",
    "XSLTPath",
    "XmlSettingType"
    ]
